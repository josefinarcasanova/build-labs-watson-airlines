"use strict";
/**
 * (C) Copyright IBM Corp. 2022.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
/**
 * IBM OpenAPI SDK Code Generator Version: 3.60.2-95dc7721-20221102-203229
 */
var extend = require("extend");
var ibm_cloud_sdk_core_1 = require("ibm-cloud-sdk-core");
var common_1 = require("../lib/common");
/**
 * With IBM CloudÂ® Secrets Manager, you can create, lease, and centrally manage secrets that are used in IBM Cloud
 * services or your custom-built applications. Secrets are stored in a dedicated instance of Secrets Manager, which is
 * built on open source HashiCorp Vault.
 *
 * API Version: 1.0.39
 * See: https://cloud.ibm.com/docs/secrets-manager
 */
var SecretsManagerV1 = /** @class */ (function (_super) {
    __extends(SecretsManagerV1, _super);
    /**
     * Construct a SecretsManagerV1 object.
     *
     * @param {Object} options - Options for the service.
     * @param {string} [options.serviceUrl] - The base url to use when contacting the service. The base url may differ between IBM Cloud regions.
     * @param {OutgoingHttpHeaders} [options.headers] - Default headers that shall be included with every request to the service.
     * @param {Authenticator} options.authenticator - The Authenticator object used to authenticate requests to the service
     * @constructor
     * @returns {SecretsManagerV1}
     */
    function SecretsManagerV1(options) {
        var _this = this;
        options = options || {};
        _this = _super.call(this, options) || this;
        if (options.serviceUrl) {
            _this.setServiceUrl(options.serviceUrl);
        }
        return _this;
    }
    /*************************
     * Factory method
     ************************/
    /**
     * Constructs an instance of SecretsManagerV1 with passed in options and external configuration.
     *
     * @param {UserOptions} [options] - The parameters to send to the service.
     * @param {string} [options.serviceName] - The name of the service to configure
     * @param {Authenticator} [options.authenticator] - The Authenticator object used to authenticate requests to the service
     * @param {string} [options.serviceUrl] - The URL for the service
     * @returns {SecretsManagerV1}
     */
    SecretsManagerV1.newInstance = function (options) {
        options = options || {};
        if (!options.serviceName) {
            options.serviceName = this.DEFAULT_SERVICE_NAME;
        }
        if (!options.authenticator) {
            options.authenticator = (0, ibm_cloud_sdk_core_1.getAuthenticatorFromEnvironment)(options.serviceName);
        }
        var service = new SecretsManagerV1(options);
        service.configureService(options.serviceName);
        if (options.serviceUrl) {
            service.setServiceUrl(options.serviceUrl);
        }
        return service;
    };
    /*************************
     * secretGroups
     ************************/
    /**
     * Create a secret group.
     *
     * Create a secret group that you can use to organize secrets and control who on your team has access to them.
     *
     * A successful request returns the ID value of the secret group, along with other metadata. To learn more about
     * secret groups, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-secret-groups).
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {CollectionMetadata} params.metadata - The metadata that describes the resource array.
     * @param {SecretGroupResource[]} params.resources - A collection of resources.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.SecretGroupDef>>}
     */
    SecretsManagerV1.prototype.createSecretGroup = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['metadata', 'resources'];
        var _validParams = ['metadata', 'resources', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'metadata': _params.metadata,
            'resources': _params.resources,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'createSecretGroup');
        var parameters = {
            options: {
                url: '/api/v1/secret_groups',
                method: 'POST',
                body: body,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List secret groups.
     *
     * List the secret groups that are available in your Secrets Manager instance.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.SecretGroupDef>>}
     */
    SecretsManagerV1.prototype.listSecretGroups = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'listSecretGroups');
        var parameters = {
            options: {
                url: '/api/v1/secret_groups',
                method: 'GET',
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get a secret group.
     *
     * Get the metadata of an existing secret group by specifying the ID of the group.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret group.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.SecretGroupDef>>}
     */
    SecretsManagerV1.prototype.getSecretGroup = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecretGroup');
        var parameters = {
            options: {
                url: '/api/v1/secret_groups/{id}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Update a secret group.
     *
     * Update the metadata of an existing secret group, such as its name or description.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret group.
     * @param {CollectionMetadata} params.metadata - The metadata that describes the resource array.
     * @param {SecretGroupMetadataUpdatable[]} params.resources - A collection of resources.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.SecretGroupDef>>}
     */
    SecretsManagerV1.prototype.updateSecretGroupMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id', 'metadata', 'resources'];
        var _validParams = ['id', 'metadata', 'resources', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'metadata': _params.metadata,
            'resources': _params.resources,
        };
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSecretGroupMetadata');
        var parameters = {
            options: {
                url: '/api/v1/secret_groups/{id}',
                method: 'PUT',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete a secret group.
     *
     * Delete a secret group by specifying the ID of the secret group.
     *
     * **Note:** To delete a secret group, it must be empty. If you need to remove a secret group that contains secrets,
     * you must first [delete the secrets](#delete-secret) that are associated with the group.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret group.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.EmptyObject>>}
     */
    SecretsManagerV1.prototype.deleteSecretGroup = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSecretGroup');
        var parameters = {
            options: {
                url: '/api/v1/secret_groups/{id}',
                method: 'DELETE',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * secrets
     ************************/
    /**
     * Create a secret.
     *
     * Create a secret or import an existing value that you can use to access or authenticate to a protected resource.
     *
     * Use this method to either generate or import an existing secret, such as an arbitrary value or a TLS certificate,
     * that you can manage in your Secrets Manager service instance. A successful request stores the secret in your
     * dedicated instance based on the secret type and data that you specify. The response returns the ID value of the
     * secret, along with other metadata.
     *
     * To learn more about the types of secrets that you can create with Secrets Manager, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-what-is-secret).
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {CollectionMetadata} params.metadata - The metadata that describes the resource array.
     * @param {SecretResource[]} params.resources - A collection of resources.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.CreateSecret>>}
     */
    SecretsManagerV1.prototype.createSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'metadata', 'resources'];
        var _validParams = ['secretType', 'metadata', 'resources', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'metadata': _params.metadata,
            'resources': _params.resources,
        };
        var path = {
            'secret_type': _params.secretType,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'createSecret');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}',
                method: 'POST',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List secrets by type.
     *
     * List the secrets in your Secrets Manager instance based on the type that you specify.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {number} [params.limit] - The number of secrets to retrieve. By default, list operations return the first
     * 200 items. To retrieve a different set of items, use `limit` with `offset` to page through your available
     * resources.
     *
     * **Usage:** If you have 20 secrets in your instance, and you want to retrieve only the first 5 secrets, use
     * `../secrets/{secret_type}?limit=5`.
     * @param {number} [params.offset] - The number of secrets to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 secrets in your instance, and you want to retrieve secrets 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.ListSecrets>>}
     */
    SecretsManagerV1.prototype.listSecrets = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType'];
        var _validParams = ['secretType', 'limit', 'offset', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'limit': _params.limit,
            'offset': _params.offset,
        };
        var path = {
            'secret_type': _params.secretType,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'listSecrets');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}',
                method: 'GET',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List all secrets.
     *
     * List all of the secrets in your Secrets Manager instance.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {number} [params.limit] - The number of secrets to retrieve. By default, list operations return the first
     * 200 items. To retrieve a different set of items, use `limit` with `offset` to page through your available
     * resources.
     *
     * **Usage:** If you have 20 secrets in your instance, and you want to retrieve only the first 5 secrets, use
     * `../secrets/{secret_type}?limit=5`.
     * @param {number} [params.offset] - The number of secrets to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 secrets in your instance, and you want to retrieve secrets 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {string} [params.search] - Filter secrets that contain the specified string. The fields that are searched
     * include: id, name, description, labels, secret_type.
     *
     * **Usage:** If you want to list only the secrets that contain the string "text", use
     * `../secrets/{secret_type}?search=text`.
     * @param {string} [params.sortBy] - Sort a list of secrets by the specified field.
     *
     * **Usage:** To sort a list of secrets by their creation date, use
     * `../secrets/{secret_type}?sort_by=creation_date`.
     * @param {string[]} [params.groups] - Filter secrets by groups.
     *
     * You can apply multiple filters by using a comma-separated list of secret group IDs. If you need to filter secrets
     * that are in the default secret group, use the `default` keyword.
     *
     * **Usage:** To retrieve a list of secrets that are associated with an existing secret group or the default group,
     * use `..?groups={secret_group_ID},default`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.ListSecrets>>}
     */
    SecretsManagerV1.prototype.listAllSecrets = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['limit', 'offset', 'search', 'sortBy', 'groups', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'limit': _params.limit,
            'offset': _params.offset,
            'search': _params.search,
            'sort_by': _params.sortBy,
            'groups': _params.groups,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'listAllSecrets');
        var parameters = {
            options: {
                url: '/api/v1/secrets',
                method: 'GET',
                qs: query,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get a secret.
     *
     * Get a secret and its details by specifying the ID of the secret.
     *
     * A successful request returns the secret data that is associated with your secret, along with other metadata. To
     * view only the details of a specified secret without retrieving its value, use the [Get secret
     * metadata](#get-secret-metadata) method.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecret>>}
     */
    SecretsManagerV1.prototype.getSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id'];
        var _validParams = ['secretType', 'id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecret');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Invoke an action on a secret.
     *
     * Invoke an action on a specified secret. This method supports the following actions:
     *
     * - `rotate`: Replace the value of a secret.
     * - `restore`: Restore a previous version of an `iam_credentials` secret.
     * - `revoke`: Revoke a private certificate.
     * - `delete_credentials`: Delete the API key that is associated with an `iam_credentials` secret.
     * - `validate_dns_challenge`: Validate challenges for a public certificate that is ordered with a manual DNS
     * provider.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} params.action - The action to perform on the specified secret.
     * @param {SecretAction} [params.secretAction] - The properties to update for the secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecret>>}
     */
    SecretsManagerV1.prototype.updateSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'action'];
        var _validParams = ['secretType', 'id', 'action', 'secretAction', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.secretAction;
        var query = {
            'action': _params.action,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSecret');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}',
                method: 'POST',
                body: body,
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete a secret.
     *
     * Delete a secret by specifying the ID of the secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.EmptyObject>>}
     */
    SecretsManagerV1.prototype.deleteSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id'];
        var _validParams = ['secretType', 'id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteSecret');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}',
                method: 'DELETE',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List versions of a secret.
     *
     * List the versions of a secret.
     *
     * A successful request returns the list of the versions along with the metadata of each version.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.ListSecretVersions>>}
     */
    SecretsManagerV1.prototype.listSecretVersions = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id'];
        var _validParams = ['secretType', 'id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'listSecretVersions');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/versions',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get a version of a secret.
     *
     * Get a version of a secret by specifying the ID of the version or the alias `previous`.
     *
     * A successful request returns the secret data that is associated with the specified version of your secret, along
     * with other metadata.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} params.versionId - The v4 UUID that uniquely identifies the secret version. You can also use
     * `previous` to retrieve the previous version.
     *
     * **Note:** To find the version ID of a secret, use the [Get secret metadata](#get-secret-metadata) method and check
     * the response details.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretVersion>>}
     */
    SecretsManagerV1.prototype.getSecretVersion = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'versionId'];
        var _validParams = ['secretType', 'id', 'versionId', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
            'version_id': _params.versionId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecretVersion');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/versions/{version_id}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Invoke an action on a version of a secret.
     *
     * Invoke an action on a specified version of a secret. This method supports the following actions:
     *
     * - `revoke`: Revoke a version of a private certificate.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} params.versionId - The v4 UUID that uniquely identifies the secret version. You can also use
     * `previous` to retrieve the previous version.
     *
     * **Note:** To find the version ID of a secret, use the [Get secret metadata](#get-secret-metadata) method and check
     * the response details.
     * @param {string} params.action - The action to perform on the specified secret version.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecret>>}
     */
    SecretsManagerV1.prototype.updateSecretVersion = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'versionId', 'action'];
        var _validParams = ['secretType', 'id', 'versionId', 'action', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'action': _params.action,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
            'version_id': _params.versionId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSecretVersion');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/versions/{version_id}',
                method: 'POST',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get the metadata of a secret version.
     *
     * Get the metadata of a secret version by specifying the ID of the version or the alias `previous`.
     *
     * A successful request returns the metadata that is associated with the specified version of your secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} params.versionId - The v4 UUID that uniquely identifies the secret version. You can also use
     * `previous` to retrieve the previous version.
     *
     * **Note:** To find the version ID of a secret, use the [Get secret metadata](#get-secret-metadata) method and check
     * the response details.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretVersionMetadata>>}
     */
    SecretsManagerV1.prototype.getSecretVersionMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'versionId'];
        var _validParams = ['secretType', 'id', 'versionId', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
            'version_id': _params.versionId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecretVersionMetadata');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/versions/{version_id}/metadata',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Update the metadata of a secret version.
     *
     * Update the metadata of a secret version, such as `version_custom_metadata`.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} params.versionId - The v4 UUID that uniquely identifies the secret version. You can also use
     * `previous` to retrieve the previous version.
     *
     * **Note:** To find the version ID of a secret, use the [Get secret metadata](#get-secret-metadata) method and check
     * the response details.
     * @param {CollectionMetadata} params.metadata - The metadata that describes the resource array.
     * @param {UpdateSecretVersionMetadata[]} params.resources - A collection of resources.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretVersionMetadata>>}
     */
    SecretsManagerV1.prototype.updateSecretVersionMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'versionId', 'metadata', 'resources'];
        var _validParams = ['secretType', 'id', 'versionId', 'metadata', 'resources', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'metadata': _params.metadata,
            'resources': _params.resources,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
            'version_id': _params.versionId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSecretVersionMetadata');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/versions/{version_id}/metadata',
                method: 'PUT',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get the metadata of a secret.
     *
     * Get the details of a secret by specifying its ID.
     *
     * A successful request returns only metadata about the secret, such as its name and creation date. To retrieve the
     * value of a secret, use the [Get a secret](#get-secret) or [Get a version of a secret](#get-secret-version) methods.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.SecretMetadataRequest>>}
     */
    SecretsManagerV1.prototype.getSecretMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id'];
        var _validParams = ['secretType', 'id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecretMetadata');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/metadata',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Update secret metadata.
     *
     * Update the metadata of a secret, such as its name or description.
     *
     * To update the actual contents of a secret, rotate the secret by using the [Invoke an action on a
     * secret](#update-secret) method.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {CollectionMetadata} params.metadata - The metadata that describes the resource array.
     * @param {SecretMetadata[]} params.resources - A collection of resources.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.SecretMetadataRequest>>}
     */
    SecretsManagerV1.prototype.updateSecretMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'metadata', 'resources'];
        var _validParams = ['secretType', 'id', 'metadata', 'resources', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'metadata': _params.metadata,
            'resources': _params.resources,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'updateSecretMetadata');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/metadata',
                method: 'PUT',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * locks
     ************************/
    /**
     * List secret locks.
     *
     * List the locks that are associated with a specified secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {number} [params.limit] - The number of locks to retrieve. By default, list operations return the first 25
     * items. To retrieve a different set of items, use `limit` with `offset` to page through your available resources.
     *
     * **Usage:** If you have 20 locks associated with your secret, and you want to retrieve only the first 5 locks, use
     * `..?limit=5`.
     * @param {number} [params.offset] - The number of locks to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 locks on your secret, and you want to retrieve locks 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {string} [params.search] - Filter locks that contain the specified string in the field "name".
     *
     * **Usage:** If you want to list only the locks that contain the string "text" in the field "name", use
     * `..?search=text`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.ListSecretLocks>>}
     */
    SecretsManagerV1.prototype.getLocks = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id'];
        var _validParams = ['secretType', 'id', 'limit', 'offset', 'search', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'limit': _params.limit,
            'offset': _params.offset,
            'search': _params.search,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getLocks');
        var parameters = {
            options: {
                url: '/api/v1/locks/{secret_type}/{id}',
                method: 'GET',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Lock a secret.
     *
     * Create a lock on the current version of a secret.
     *
     * A lock can be used to prevent a secret from being deleted or modified while it's in use by your applications. A
     * successful request attaches a new lock to your secret, or replaces a lock of the same name if it already exists.
     * Additionally, you can use this method to clear any matching locks on a secret by using one of the following
     * optional lock modes:
     *
     * - `exclusive`: Removes any other locks with matching names if they are found in the previous version of the secret.
     * - `exclusive_delete`: Same as `exclusive`, but also permanently deletes the data of the previous secret version if
     * it doesn't have any locks.
     *
     * For more information about locking secrets, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-secret-locks).
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {LockSecretBodyLocksItem[]} [params.locks] - The lock data to be attached to a secret version.
     * @param {string} [params.mode] - An optional lock mode. At lock creation, you can set one of the following modes to
     * clear any matching locks on a secret version. Note: When you are locking the `previous` version, the mode parameter
     * is ignored.
     *
     * - `exclusive`: Removes any other locks with matching names if they are found in the previous version of the secret.
     * - `exclusive_delete`: Same as `exclusive`, but also permanently deletes the data of the previous secret version if
     * it doesn't have any locks.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretLocks>>}
     */
    SecretsManagerV1.prototype.lockSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id'];
        var _validParams = ['secretType', 'id', 'locks', 'mode', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'locks': _params.locks,
        };
        var query = {
            'mode': _params.mode,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'lockSecret');
        var parameters = {
            options: {
                url: '/api/v1/locks/{secret_type}/{id}/lock',
                method: 'POST',
                body: body,
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Unlock a secret.
     *
     * Delete one or more locks that are associated with the current version of a secret.
     *
     * A successful request deletes the locks that you specify. To remove all locks, you can pass `{"locks": ["*"]}` in in
     * the request body. Otherwise, specify the names of the locks that you want to delete. For example, `{"locks":
     * ["lock1", "lock2"]}`.
     *
     * **Note:** A secret is considered unlocked and able to be revoked or deleted only after all of its locks are
     * removed. To understand whether a secret contains locks, check the `locks_total` field that is returned as part of
     * the metadata of your secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string[]} [params.locks] - A comma-separated list of locks to delete.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretLocks>>}
     */
    SecretsManagerV1.prototype.unlockSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id'];
        var _validParams = ['secretType', 'id', 'locks', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'locks': _params.locks,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'unlockSecret');
        var parameters = {
            options: {
                url: '/api/v1/locks/{secret_type}/{id}/unlock',
                method: 'POST',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List secret version locks.
     *
     * List the locks that are associated with a specified secret version.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} params.versionId - The v4 UUID that uniquely identifies the secret version. You can also use
     * `previous` to retrieve the previous version.
     *
     * **Note:** To find the version ID of a secret, use the [Get secret metadata](#get-secret-metadata) method and check
     * the response details.
     * @param {number} [params.limit] - The number of locks to retrieve. By default, list operations return the first 25
     * items. To retrieve a different set of items, use `limit` with `offset` to page through your available resources.
     *
     * **Usage:** If you have 20 locks associated with your secret, and you want to retrieve only the first 5 locks, use
     * `..?limit=5`.
     * @param {number} [params.offset] - The number of locks to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 locks on your secret, and you want to retrieve locks 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {string} [params.search] - Filter locks that contain the specified string in the field "name".
     *
     * **Usage:** If you want to list only the locks that contain the string "text" in the field "name", use
     * `..?search=text`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.ListSecretLocks>>}
     */
    SecretsManagerV1.prototype.getSecretVersionLocks = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'versionId'];
        var _validParams = ['secretType', 'id', 'versionId', 'limit', 'offset', 'search', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'limit': _params.limit,
            'offset': _params.offset,
            'search': _params.search,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
            'version_id': _params.versionId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getSecretVersionLocks');
        var parameters = {
            options: {
                url: '/api/v1/locks/{secret_type}/{id}/versions/{version_id}',
                method: 'GET',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Lock a secret version.
     *
     * Create a lock on the specified version of a secret.
     *
     * A lock can be used to prevent a secret from being deleted or modified while it's in use by your applications. A
     * successful request attaches a new lock to the specified version, or replaces a lock of the same name if it already
     * exists. Additionally, you can use this method to clear any matching locks on a secret version by using one of the
     * following optional lock modes:
     *
     * - `exclusive`: Removes any other locks with matching names if they are found in the previous version of the secret.
     * - `exclusive_delete`: Same as `exclusive`, but also permanently deletes the data of the previous secret version if
     * it doesn't have any locks.
     *
     * For more information about locking secrets, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-secret-locks).
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} params.versionId - The v4 UUID that uniquely identifies the secret version. You can also use
     * `previous` to retrieve the previous version.
     *
     * **Note:** To find the version ID of a secret, use the [Get secret metadata](#get-secret-metadata) method and check
     * the response details.
     * @param {LockSecretBodyLocksItem[]} [params.locks] - The lock data to be attached to a secret version.
     * @param {string} [params.mode] - An optional lock mode. At lock creation, you can set one of the following modes to
     * clear any matching locks on a secret version. Note: When you are locking the `previous` version, the mode parameter
     * is ignored.
     *
     * - `exclusive`: Removes any other locks with matching names if they are found in the previous version of the secret.
     * - `exclusive_delete`: Same as `exclusive`, but also permanently deletes the data of the previous secret version if
     * it doesn't have any locks.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretLocks>>}
     */
    SecretsManagerV1.prototype.lockSecretVersion = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'versionId'];
        var _validParams = ['secretType', 'id', 'versionId', 'locks', 'mode', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'locks': _params.locks,
        };
        var query = {
            'mode': _params.mode,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
            'version_id': _params.versionId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'lockSecretVersion');
        var parameters = {
            options: {
                url: '/api/v1/locks/{secret_type}/{id}/versions/{version_id}/lock',
                method: 'POST',
                body: body,
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Unlock a secret version.
     *
     * Delete one or more locks that are associated with the specified secret version.
     *
     * A successful request deletes the locks that you specify. To remove all locks, you can pass `{"locks": ["*"]}` in in
     * the request body. Otherwise, specify the names of the locks that you want to delete. For example, `{"locks":
     * ["lock-1", "lock-2"]}`.
     *
     * **Note:** A secret is considered unlocked and able to be revoked or deleted only after all of its locks are
     * removed. To understand whether a secret contains locks, check the `locks_total` field that is returned as part of
     * the metadata of your secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} params.versionId - The v4 UUID that uniquely identifies the secret version. You can also use
     * `previous` to retrieve the previous version.
     *
     * **Note:** To find the version ID of a secret, use the [Get secret metadata](#get-secret-metadata) method and check
     * the response details.
     * @param {string[]} [params.locks] - A comma-separated list of locks to delete.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretLocks>>}
     */
    SecretsManagerV1.prototype.unlockSecretVersion = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'versionId'];
        var _validParams = ['secretType', 'id', 'versionId', 'locks', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'locks': _params.locks,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
            'version_id': _params.versionId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'unlockSecretVersion');
        var parameters = {
            options: {
                url: '/api/v1/locks/{secret_type}/{id}/versions/{version_id}/unlock',
                method: 'POST',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List all secrets and locks.
     *
     * List the lock details that are associated with all secrets in your Secrets Manager instance.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {number} [params.limit] - The number of secrets with associated locks to retrieve. By default, list
     * operations return the first 25 items. To retrieve a different set of items, use `limit` with `offset` to page
     * through your available resources.
     *
     * **Usage:** If you have 20 secrets in your instance, and you want to retrieve only the first 5, use
     * `..?limit=5`.
     * @param {number} [params.offset] - The number of secrets to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 secrets in your instance, and you want to retrieve secrets 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {string} [params.search] - Filter locks that contain the specified string in the field "name".
     *
     * **Usage:** If you want to list only the locks that contain the string "text" in the field "name", use
     * `..?search=text`.
     * @param {string[]} [params.groups] - Filter secrets by groups.
     *
     * You can apply multiple filters by using a comma-separated list of secret group IDs. If you need to filter secrets
     * that are in the default secret group, use the `default` keyword.
     *
     * **Usage:** To retrieve a list of secrets that are associated with an existing secret group or the default group,
     * use `..?groups={secret_group_ID},default`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetInstanceLocks>>}
     */
    SecretsManagerV1.prototype.listInstanceSecretsLocks = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['limit', 'offset', 'search', 'groups', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'limit': _params.limit,
            'offset': _params.offset,
            'search': _params.search,
            'groups': _params.groups,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'listInstanceSecretsLocks');
        var parameters = {
            options: {
                url: '/api/v1/locks',
                method: 'GET',
                qs: query,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * policies
     ************************/
    /**
     * Set secret policies.
     *
     * Create or update one or more policies, such as an [automatic rotation
     * policy](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-automatic-rotation), for the specified
     * secret. To remove a policy, keep the resources block empty.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {CollectionMetadata} params.metadata - The metadata that describes the resource array.
     * @param {SecretPolicyRotation[]} params.resources - A collection of resources.
     * @param {string} [params.policy] - The type of policy that is associated with the specified secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretPolicies>>}
     */
    SecretsManagerV1.prototype.putPolicy = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id', 'metadata', 'resources'];
        var _validParams = ['secretType', 'id', 'metadata', 'resources', 'policy', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'metadata': _params.metadata,
            'resources': _params.resources,
        };
        var query = {
            'policy': _params.policy,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'putPolicy');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/policies',
                method: 'PUT',
                body: body,
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List secret policies.
     *
     * List the rotation policies that are associated with a specified secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.id - The v4 UUID that uniquely identifies the secret.
     * @param {string} [params.policy] - The type of policy that is associated with the specified secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSecretPolicies>>}
     */
    SecretsManagerV1.prototype.getPolicy = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'id'];
        var _validParams = ['secretType', 'id', 'policy', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'policy': _params.policy,
        };
        var path = {
            'secret_type': _params.secretType,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getPolicy');
        var parameters = {
            options: {
                url: '/api/v1/secrets/{secret_type}/{id}/policies',
                method: 'GET',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * config
     ************************/
    /**
     * Set the configuration of a secret type.
     *
     * Set the configuration for the specified secret type.
     *
     * Use this method to configure the IAM credentials (`iam_credentials`) engine for your service instance. Looking to
     * order or generate certificates? To configure the public certificates (`public_cert`) or  private certificates
     * (`private_cert`) engines, use the [Add a configuration](#create_config_element) method.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {EngineConfig} params.engineConfig - Properties to update for a secrets engine.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.EmptyObject>>}
     */
    SecretsManagerV1.prototype.putConfig = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'engineConfig'];
        var _validParams = ['secretType', 'engineConfig', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.engineConfig;
        var path = {
            'secret_type': _params.secretType,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'putConfig');
        var parameters = {
            options: {
                url: '/api/v1/config/{secret_type}',
                method: 'PUT',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get the configuration of a secret type.
     *
     * Get the configuration that is associated with the specified secret type.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetConfig>>}
     */
    SecretsManagerV1.prototype.getConfig = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType'];
        var _validParams = ['secretType', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getConfig');
        var parameters = {
            options: {
                url: '/api/v1/config/{secret_type}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Add a configuration.
     *
     * Add a configuration element to the specified secret type.
     *
     * Use this method to define the configurations that are required to enable the public certificates (`public_cert`)
     * and private certificates (`private_cert`) engines.
     *
     * You can add multiple configurations for your instance as follows:
     *
     * - Up to 10 public certificate authority configurations
     * - Up to 10 DNS provider configurations
     * - Up to 10 private root certificate authority configurations
     * - Up to 10 private intermediate certificate authority configurations
     * - Up to 10 certificate templates.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.configElement - The configuration element to define or manage.
     * @param {string} params.name - The human-readable name to assign to your configuration.
     * @param {string} params.type - The type of configuration. Value options differ depending on the `config_element`
     * property that you want to define.
     * @param {ConfigElementDefConfig} params.config - The configuration to define for the specified secret type.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSingleConfigElement>>}
     */
    SecretsManagerV1.prototype.createConfigElement = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'configElement', 'name', 'type', 'config'];
        var _validParams = ['secretType', 'configElement', 'name', 'type', 'config', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'name': _params.name,
            'type': _params.type,
            'config': _params.config,
        };
        var path = {
            'secret_type': _params.secretType,
            'config_element': _params.configElement,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'createConfigElement');
        var parameters = {
            options: {
                url: '/api/v1/config/{secret_type}/{config_element}',
                method: 'POST',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List configurations.
     *
     * List the configuration elements that are associated with a specified secret type.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.configElement - The configuration element to define or manage.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetConfigElements>>}
     */
    SecretsManagerV1.prototype.getConfigElements = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'configElement'];
        var _validParams = ['secretType', 'configElement', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'config_element': _params.configElement,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getConfigElements');
        var parameters = {
            options: {
                url: '/api/v1/config/{secret_type}/{config_element}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get a configuration.
     *
     * Get the details of a specific configuration that is associated with a secret type.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.configElement - The configuration element to define or manage.
     * @param {string} params.configName - The name of your configuration.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSingleConfigElement>>}
     */
    SecretsManagerV1.prototype.getConfigElement = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'configElement', 'configName'];
        var _validParams = ['secretType', 'configElement', 'configName', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'config_element': _params.configElement,
            'config_name': _params.configName,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getConfigElement');
        var parameters = {
            options: {
                url: '/api/v1/config/{secret_type}/{config_element}/{config_name}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Update a configuration.
     *
     * Update a configuration element that is associated with the specified secret type.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.configElement - The configuration element to define or manage.
     * @param {string} params.configName - The name of your configuration.
     * @param {string} params.type - The type of configuration. Value options differ depending on the `config_element`
     * property that you want to define.
     * @param {JsonObject} params.config - Properties that describe a configuration, which depends on type.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetSingleConfigElement>>}
     */
    SecretsManagerV1.prototype.updateConfigElement = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'configElement', 'configName', 'type', 'config'];
        var _validParams = ['secretType', 'configElement', 'configName', 'type', 'config', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'type': _params.type,
            'config': _params.config,
        };
        var path = {
            'secret_type': _params.secretType,
            'config_element': _params.configElement,
            'config_name': _params.configName,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'updateConfigElement');
        var parameters = {
            options: {
                url: '/api/v1/config/{secret_type}/{config_element}/{config_name}',
                method: 'PUT',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Invoke an action on a configuration.
     *
     * Invoke an action on a specified configuration element. This method supports the following actions:
     *
     * - `sign_intermediate`: Sign an intermediate certificate authority.
     * - `sign_csr`: Sign a certificate signing request.
     * - `set_signed`: Set a signed intermediate certificate authority.
     * - `revoke`: Revoke an internally signed intermediate certificate authority certificate.
     * - `rotate_crl`: Rotate the certificate revocation list (CRL) of an intermediate certificate authority.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.configElement - The configuration element on which the action is applied.
     * @param {string} params.configName - The name of the certificate authority.
     * @param {string} params.action - The action to perform on the specified configuration element.
     * @param {ConfigAction} [params.config] - Properties that describe an action on a configuration element.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.ConfigElementActionResult>>}
     */
    SecretsManagerV1.prototype.actionOnConfigElement = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'configElement', 'configName', 'action'];
        var _validParams = [
            'secretType',
            'configElement',
            'configName',
            'action',
            'config',
            'headers',
        ];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'config': _params.config,
        };
        var query = {
            'action': _params.action,
        };
        var path = {
            'secret_type': _params.secretType,
            'config_element': _params.configElement,
            'config_name': _params.configName,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'actionOnConfigElement');
        var parameters = {
            options: {
                url: '/api/v1/config/{secret_type}/{config_element}/{config_name}',
                method: 'POST',
                body: body,
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete a configuration.
     *
     * Delete a configuration element from the specified secret type.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretType - The secret type.
     * @param {string} params.configElement - The configuration element to define or manage.
     * @param {string} params.configName - The name of your configuration.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.EmptyObject>>}
     */
    SecretsManagerV1.prototype.deleteConfigElement = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretType', 'configElement', 'configName'];
        var _validParams = ['secretType', 'configElement', 'configName', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_type': _params.secretType,
            'config_element': _params.configElement,
            'config_name': _params.configName,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteConfigElement');
        var parameters = {
            options: {
                url: '/api/v1/config/{secret_type}/{config_element}/{config_name}',
                method: 'DELETE',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * notifications
     ************************/
    /**
     * Register with Event Notifications.
     *
     * Create a registration between a Secrets Manager instance and [Event
     * Notifications](https://cloud.ibm.com/apidocs/event-notifications).
     *
     * A successful request adds Secrets Manager as a source that you can reference from your Event Notifications
     * instance. For more information about enabling notifications for Secrets Manager, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-event-notifications).
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.eventNotificationsInstanceCrn - The Cloud Resource Name (CRN) of the connected Event
     * Notifications instance.
     * @param {string} params.eventNotificationsSourceName - The name that is displayed as a source in your Event
     * Notifications instance.
     * @param {string} [params.eventNotificationsSourceDescription] - An optional description for the source in your Event
     * Notifications instance.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetNotificationsSettings>>}
     */
    SecretsManagerV1.prototype.createNotificationsRegistration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['eventNotificationsInstanceCrn', 'eventNotificationsSourceName'];
        var _validParams = [
            'eventNotificationsInstanceCrn',
            'eventNotificationsSourceName',
            'eventNotificationsSourceDescription',
            'headers',
        ];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'event_notifications_instance_crn': _params.eventNotificationsInstanceCrn,
            'event_notifications_source_name': _params.eventNotificationsSourceName,
            'event_notifications_source_description': _params.eventNotificationsSourceDescription,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'createNotificationsRegistration');
        var parameters = {
            options: {
                url: '/api/v1/notifications/registration',
                method: 'POST',
                body: body,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get Event Notifications registration details.
     *
     * Get the details of an existing registration between a Secrets Manager instance and Event Notifications.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.GetNotificationsSettings>>}
     */
    SecretsManagerV1.prototype.getNotificationsRegistration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'getNotificationsRegistration');
        var parameters = {
            options: {
                url: '/api/v1/notifications/registration',
                method: 'GET',
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Unregister from Event Notifications.
     *
     * Delete a registration between a Secrets Manager instance and Event Notifications.
     *
     * A successful request removes your Secrets Manager instance as a source in Event Notifications.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.EmptyObject>>}
     */
    SecretsManagerV1.prototype.deleteNotificationsRegistration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'deleteNotificationsRegistration');
        var parameters = {
            options: {
                url: '/api/v1/notifications/registration',
                method: 'DELETE',
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Send a test event.
     *
     * Send a test event from a Secrets Manager instance to a configured [Event
     * Notifications](https://cloud.ibm.com/apidocs/event-notifications) instance.
     *
     * A successful request sends a test event to the Event Notifications instance. For more information about enabling
     * notifications for Secrets Manager, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-event-notifications).
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV1.Response<SecretsManagerV1.EmptyObject>>}
     */
    SecretsManagerV1.prototype.sendTestNotification = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV1.DEFAULT_SERVICE_NAME, 'v1', 'sendTestNotification');
        var parameters = {
            options: {
                url: '/api/v1/notifications/test',
                method: 'GET',
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    SecretsManagerV1.DEFAULT_SERVICE_NAME = 'secrets_manager';
    return SecretsManagerV1;
}(ibm_cloud_sdk_core_1.BaseService));
/*************************
 * interfaces
 ************************/
(function (SecretsManagerV1) {
    /** Constants for the `createSecret` operation. */
    var CreateSecretConstants;
    (function (CreateSecretConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = CreateSecretConstants.SecretType || (CreateSecretConstants.SecretType = {}));
    })(CreateSecretConstants = SecretsManagerV1.CreateSecretConstants || (SecretsManagerV1.CreateSecretConstants = {}));
    /** Constants for the `listSecrets` operation. */
    var ListSecretsConstants;
    (function (ListSecretsConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = ListSecretsConstants.SecretType || (ListSecretsConstants.SecretType = {}));
    })(ListSecretsConstants = SecretsManagerV1.ListSecretsConstants || (SecretsManagerV1.ListSecretsConstants = {}));
    /** Constants for the `listAllSecrets` operation. */
    var ListAllSecretsConstants;
    (function (ListAllSecretsConstants) {
        /** Sort a list of secrets by the specified field. **Usage:** To sort a list of secrets by their creation date, use `../secrets/{secret_type}?sort_by=creation_date`. */
        var SortBy;
        (function (SortBy) {
            SortBy["ID"] = "id";
            SortBy["CREATION_DATE"] = "creation_date";
            SortBy["EXPIRATION_DATE"] = "expiration_date";
            SortBy["SECRET_TYPE"] = "secret_type";
            SortBy["NAME"] = "name";
        })(SortBy = ListAllSecretsConstants.SortBy || (ListAllSecretsConstants.SortBy = {}));
    })(ListAllSecretsConstants = SecretsManagerV1.ListAllSecretsConstants || (SecretsManagerV1.ListAllSecretsConstants = {}));
    /** Constants for the `getSecret` operation. */
    var GetSecretConstants;
    (function (GetSecretConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = GetSecretConstants.SecretType || (GetSecretConstants.SecretType = {}));
    })(GetSecretConstants = SecretsManagerV1.GetSecretConstants || (SecretsManagerV1.GetSecretConstants = {}));
    /** Constants for the `updateSecret` operation. */
    var UpdateSecretConstants;
    (function (UpdateSecretConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = UpdateSecretConstants.SecretType || (UpdateSecretConstants.SecretType = {}));
        /** The action to perform on the specified secret. */
        var Action;
        (function (Action) {
            Action["ROTATE"] = "rotate";
            Action["RESTORE"] = "restore";
            Action["REVOKE"] = "revoke";
            Action["DELETE_CREDENTIALS"] = "delete_credentials";
            Action["VALIDATE_DNS_CHALLENGE"] = "validate_dns_challenge";
        })(Action = UpdateSecretConstants.Action || (UpdateSecretConstants.Action = {}));
    })(UpdateSecretConstants = SecretsManagerV1.UpdateSecretConstants || (SecretsManagerV1.UpdateSecretConstants = {}));
    /** Constants for the `deleteSecret` operation. */
    var DeleteSecretConstants;
    (function (DeleteSecretConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = DeleteSecretConstants.SecretType || (DeleteSecretConstants.SecretType = {}));
    })(DeleteSecretConstants = SecretsManagerV1.DeleteSecretConstants || (SecretsManagerV1.DeleteSecretConstants = {}));
    /** Constants for the `listSecretVersions` operation. */
    var ListSecretVersionsConstants;
    (function (ListSecretVersionsConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = ListSecretVersionsConstants.SecretType || (ListSecretVersionsConstants.SecretType = {}));
    })(ListSecretVersionsConstants = SecretsManagerV1.ListSecretVersionsConstants || (SecretsManagerV1.ListSecretVersionsConstants = {}));
    /** Constants for the `getSecretVersion` operation. */
    var GetSecretVersionConstants;
    (function (GetSecretVersionConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = GetSecretVersionConstants.SecretType || (GetSecretVersionConstants.SecretType = {}));
    })(GetSecretVersionConstants = SecretsManagerV1.GetSecretVersionConstants || (SecretsManagerV1.GetSecretVersionConstants = {}));
    /** Constants for the `updateSecretVersion` operation. */
    var UpdateSecretVersionConstants;
    (function (UpdateSecretVersionConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = UpdateSecretVersionConstants.SecretType || (UpdateSecretVersionConstants.SecretType = {}));
        /** The action to perform on the specified secret version. */
        var Action;
        (function (Action) {
            Action["REVOKE"] = "revoke";
        })(Action = UpdateSecretVersionConstants.Action || (UpdateSecretVersionConstants.Action = {}));
    })(UpdateSecretVersionConstants = SecretsManagerV1.UpdateSecretVersionConstants || (SecretsManagerV1.UpdateSecretVersionConstants = {}));
    /** Constants for the `getSecretVersionMetadata` operation. */
    var GetSecretVersionMetadataConstants;
    (function (GetSecretVersionMetadataConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = GetSecretVersionMetadataConstants.SecretType || (GetSecretVersionMetadataConstants.SecretType = {}));
    })(GetSecretVersionMetadataConstants = SecretsManagerV1.GetSecretVersionMetadataConstants || (SecretsManagerV1.GetSecretVersionMetadataConstants = {}));
    /** Constants for the `updateSecretVersionMetadata` operation. */
    var UpdateSecretVersionMetadataConstants;
    (function (UpdateSecretVersionMetadataConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = UpdateSecretVersionMetadataConstants.SecretType || (UpdateSecretVersionMetadataConstants.SecretType = {}));
    })(UpdateSecretVersionMetadataConstants = SecretsManagerV1.UpdateSecretVersionMetadataConstants || (SecretsManagerV1.UpdateSecretVersionMetadataConstants = {}));
    /** Constants for the `getSecretMetadata` operation. */
    var GetSecretMetadataConstants;
    (function (GetSecretMetadataConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = GetSecretMetadataConstants.SecretType || (GetSecretMetadataConstants.SecretType = {}));
    })(GetSecretMetadataConstants = SecretsManagerV1.GetSecretMetadataConstants || (SecretsManagerV1.GetSecretMetadataConstants = {}));
    /** Constants for the `updateSecretMetadata` operation. */
    var UpdateSecretMetadataConstants;
    (function (UpdateSecretMetadataConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = UpdateSecretMetadataConstants.SecretType || (UpdateSecretMetadataConstants.SecretType = {}));
    })(UpdateSecretMetadataConstants = SecretsManagerV1.UpdateSecretMetadataConstants || (SecretsManagerV1.UpdateSecretMetadataConstants = {}));
    /** Constants for the `getLocks` operation. */
    var GetLocksConstants;
    (function (GetLocksConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = GetLocksConstants.SecretType || (GetLocksConstants.SecretType = {}));
    })(GetLocksConstants = SecretsManagerV1.GetLocksConstants || (SecretsManagerV1.GetLocksConstants = {}));
    /** Constants for the `lockSecret` operation. */
    var LockSecretConstants;
    (function (LockSecretConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = LockSecretConstants.SecretType || (LockSecretConstants.SecretType = {}));
        /** An optional lock mode. At lock creation, you can set one of the following modes to clear any matching locks on a secret version. Note: When you are locking the `previous` version, the mode parameter is ignored. - `exclusive`: Removes any other locks with matching names if they are found in the previous version of the secret. - `exclusive_delete`: Same as `exclusive`, but also permanently deletes the data of the previous secret version if it doesn't have any locks. */
        var Mode;
        (function (Mode) {
            Mode["EXCLUSIVE"] = "exclusive";
            Mode["EXCLUSIVE_DELETE"] = "exclusive_delete";
        })(Mode = LockSecretConstants.Mode || (LockSecretConstants.Mode = {}));
    })(LockSecretConstants = SecretsManagerV1.LockSecretConstants || (SecretsManagerV1.LockSecretConstants = {}));
    /** Constants for the `unlockSecret` operation. */
    var UnlockSecretConstants;
    (function (UnlockSecretConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = UnlockSecretConstants.SecretType || (UnlockSecretConstants.SecretType = {}));
    })(UnlockSecretConstants = SecretsManagerV1.UnlockSecretConstants || (SecretsManagerV1.UnlockSecretConstants = {}));
    /** Constants for the `getSecretVersionLocks` operation. */
    var GetSecretVersionLocksConstants;
    (function (GetSecretVersionLocksConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = GetSecretVersionLocksConstants.SecretType || (GetSecretVersionLocksConstants.SecretType = {}));
    })(GetSecretVersionLocksConstants = SecretsManagerV1.GetSecretVersionLocksConstants || (SecretsManagerV1.GetSecretVersionLocksConstants = {}));
    /** Constants for the `lockSecretVersion` operation. */
    var LockSecretVersionConstants;
    (function (LockSecretVersionConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = LockSecretVersionConstants.SecretType || (LockSecretVersionConstants.SecretType = {}));
        /** An optional lock mode. At lock creation, you can set one of the following modes to clear any matching locks on a secret version. Note: When you are locking the `previous` version, the mode parameter is ignored. - `exclusive`: Removes any other locks with matching names if they are found in the previous version of the secret. - `exclusive_delete`: Same as `exclusive`, but also permanently deletes the data of the previous secret version if it doesn't have any locks. */
        var Mode;
        (function (Mode) {
            Mode["EXCLUSIVE"] = "exclusive";
            Mode["EXCLUSIVE_DELETE"] = "exclusive_delete";
        })(Mode = LockSecretVersionConstants.Mode || (LockSecretVersionConstants.Mode = {}));
    })(LockSecretVersionConstants = SecretsManagerV1.LockSecretVersionConstants || (SecretsManagerV1.LockSecretVersionConstants = {}));
    /** Constants for the `unlockSecretVersion` operation. */
    var UnlockSecretVersionConstants;
    (function (UnlockSecretVersionConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["ARBITRARY"] = "arbitrary";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["IMPORTED_CERT"] = "imported_cert";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["KV"] = "kv";
        })(SecretType = UnlockSecretVersionConstants.SecretType || (UnlockSecretVersionConstants.SecretType = {}));
    })(UnlockSecretVersionConstants = SecretsManagerV1.UnlockSecretVersionConstants || (SecretsManagerV1.UnlockSecretVersionConstants = {}));
    /** Constants for the `putPolicy` operation. */
    var PutPolicyConstants;
    (function (PutPolicyConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = PutPolicyConstants.SecretType || (PutPolicyConstants.SecretType = {}));
        /** The type of policy that is associated with the specified secret. */
        var Policy;
        (function (Policy) {
            Policy["ROTATION"] = "rotation";
        })(Policy = PutPolicyConstants.Policy || (PutPolicyConstants.Policy = {}));
    })(PutPolicyConstants = SecretsManagerV1.PutPolicyConstants || (SecretsManagerV1.PutPolicyConstants = {}));
    /** Constants for the `getPolicy` operation. */
    var GetPolicyConstants;
    (function (GetPolicyConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["USERNAME_PASSWORD"] = "username_password";
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = GetPolicyConstants.SecretType || (GetPolicyConstants.SecretType = {}));
        /** The type of policy that is associated with the specified secret. */
        var Policy;
        (function (Policy) {
            Policy["ROTATION"] = "rotation";
        })(Policy = GetPolicyConstants.Policy || (GetPolicyConstants.Policy = {}));
    })(GetPolicyConstants = SecretsManagerV1.GetPolicyConstants || (SecretsManagerV1.GetPolicyConstants = {}));
    /** Constants for the `putConfig` operation. */
    var PutConfigConstants;
    (function (PutConfigConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
        })(SecretType = PutConfigConstants.SecretType || (PutConfigConstants.SecretType = {}));
    })(PutConfigConstants = SecretsManagerV1.PutConfigConstants || (SecretsManagerV1.PutConfigConstants = {}));
    /** Constants for the `getConfig` operation. */
    var GetConfigConstants;
    (function (GetConfigConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["IAM_CREDENTIALS"] = "iam_credentials";
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = GetConfigConstants.SecretType || (GetConfigConstants.SecretType = {}));
    })(GetConfigConstants = SecretsManagerV1.GetConfigConstants || (SecretsManagerV1.GetConfigConstants = {}));
    /** Constants for the `createConfigElement` operation. */
    var CreateConfigElementConstants;
    (function (CreateConfigElementConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = CreateConfigElementConstants.SecretType || (CreateConfigElementConstants.SecretType = {}));
        /** The configuration element to define or manage. */
        var ConfigElement;
        (function (ConfigElement) {
            ConfigElement["CERTIFICATE_AUTHORITIES"] = "certificate_authorities";
            ConfigElement["DNS_PROVIDERS"] = "dns_providers";
            ConfigElement["ROOT_CERTIFICATE_AUTHORITIES"] = "root_certificate_authorities";
            ConfigElement["INTERMEDIATE_CERTIFICATE_AUTHORITIES"] = "intermediate_certificate_authorities";
            ConfigElement["CERTIFICATE_TEMPLATES"] = "certificate_templates";
        })(ConfigElement = CreateConfigElementConstants.ConfigElement || (CreateConfigElementConstants.ConfigElement = {}));
        /** The type of configuration. Value options differ depending on the `config_element` property that you want to define. */
        var Type;
        (function (Type) {
            Type["LETSENCRYPT"] = "letsencrypt";
            Type["LETSENCRYPT_STAGE"] = "letsencrypt-stage";
            Type["CIS"] = "cis";
            Type["CLASSIC_INFRASTRUCTURE"] = "classic_infrastructure";
            Type["ROOT_CERTIFICATE_AUTHORITY"] = "root_certificate_authority";
            Type["INTERMEDIATE_CERTIFICATE_AUTHORITY"] = "intermediate_certificate_authority";
            Type["CERTIFICATE_TEMPLATE"] = "certificate_template";
        })(Type = CreateConfigElementConstants.Type || (CreateConfigElementConstants.Type = {}));
    })(CreateConfigElementConstants = SecretsManagerV1.CreateConfigElementConstants || (SecretsManagerV1.CreateConfigElementConstants = {}));
    /** Constants for the `getConfigElements` operation. */
    var GetConfigElementsConstants;
    (function (GetConfigElementsConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = GetConfigElementsConstants.SecretType || (GetConfigElementsConstants.SecretType = {}));
        /** The configuration element to define or manage. */
        var ConfigElement;
        (function (ConfigElement) {
            ConfigElement["CERTIFICATE_AUTHORITIES"] = "certificate_authorities";
            ConfigElement["DNS_PROVIDERS"] = "dns_providers";
            ConfigElement["ROOT_CERTIFICATE_AUTHORITIES"] = "root_certificate_authorities";
            ConfigElement["INTERMEDIATE_CERTIFICATE_AUTHORITIES"] = "intermediate_certificate_authorities";
            ConfigElement["CERTIFICATE_TEMPLATES"] = "certificate_templates";
        })(ConfigElement = GetConfigElementsConstants.ConfigElement || (GetConfigElementsConstants.ConfigElement = {}));
    })(GetConfigElementsConstants = SecretsManagerV1.GetConfigElementsConstants || (SecretsManagerV1.GetConfigElementsConstants = {}));
    /** Constants for the `getConfigElement` operation. */
    var GetConfigElementConstants;
    (function (GetConfigElementConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = GetConfigElementConstants.SecretType || (GetConfigElementConstants.SecretType = {}));
        /** The configuration element to define or manage. */
        var ConfigElement;
        (function (ConfigElement) {
            ConfigElement["CERTIFICATE_AUTHORITIES"] = "certificate_authorities";
            ConfigElement["DNS_PROVIDERS"] = "dns_providers";
            ConfigElement["ROOT_CERTIFICATE_AUTHORITIES"] = "root_certificate_authorities";
            ConfigElement["INTERMEDIATE_CERTIFICATE_AUTHORITIES"] = "intermediate_certificate_authorities";
            ConfigElement["CERTIFICATE_TEMPLATES"] = "certificate_templates";
        })(ConfigElement = GetConfigElementConstants.ConfigElement || (GetConfigElementConstants.ConfigElement = {}));
    })(GetConfigElementConstants = SecretsManagerV1.GetConfigElementConstants || (SecretsManagerV1.GetConfigElementConstants = {}));
    /** Constants for the `updateConfigElement` operation. */
    var UpdateConfigElementConstants;
    (function (UpdateConfigElementConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = UpdateConfigElementConstants.SecretType || (UpdateConfigElementConstants.SecretType = {}));
        /** The configuration element to define or manage. */
        var ConfigElement;
        (function (ConfigElement) {
            ConfigElement["CERTIFICATE_AUTHORITIES"] = "certificate_authorities";
            ConfigElement["DNS_PROVIDERS"] = "dns_providers";
            ConfigElement["ROOT_CERTIFICATE_AUTHORITIES"] = "root_certificate_authorities";
            ConfigElement["INTERMEDIATE_CERTIFICATE_AUTHORITIES"] = "intermediate_certificate_authorities";
            ConfigElement["CERTIFICATE_TEMPLATES"] = "certificate_templates";
        })(ConfigElement = UpdateConfigElementConstants.ConfigElement || (UpdateConfigElementConstants.ConfigElement = {}));
        /** The type of configuration. Value options differ depending on the `config_element` property that you want to define. */
        var Type;
        (function (Type) {
            Type["LETSENCRYPT"] = "letsencrypt";
            Type["LETSENCRYPT_STAGE"] = "letsencrypt-stage";
            Type["CIS"] = "cis";
            Type["CLASSIC_INFRASTRUCTURE"] = "classic_infrastructure";
            Type["ROOT_CERTIFICATE_AUTHORITY"] = "root_certificate_authority";
            Type["INTERMEDIATE_CERTIFICATE_AUTHORITY"] = "intermediate_certificate_authority";
            Type["CERTIFICATE_TEMPLATE"] = "certificate_template";
        })(Type = UpdateConfigElementConstants.Type || (UpdateConfigElementConstants.Type = {}));
    })(UpdateConfigElementConstants = SecretsManagerV1.UpdateConfigElementConstants || (SecretsManagerV1.UpdateConfigElementConstants = {}));
    /** Constants for the `actionOnConfigElement` operation. */
    var ActionOnConfigElementConstants;
    (function (ActionOnConfigElementConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = ActionOnConfigElementConstants.SecretType || (ActionOnConfigElementConstants.SecretType = {}));
        /** The configuration element on which the action is applied. */
        var ConfigElement;
        (function (ConfigElement) {
            ConfigElement["ROOT_CERTIFICATE_AUTHORITIES"] = "root_certificate_authorities";
            ConfigElement["INTERMEDIATE_CERTIFICATE_AUTHORITIES"] = "intermediate_certificate_authorities";
        })(ConfigElement = ActionOnConfigElementConstants.ConfigElement || (ActionOnConfigElementConstants.ConfigElement = {}));
        /** The action to perform on the specified configuration element. */
        var Action;
        (function (Action) {
            Action["SIGN_INTERMEDIATE"] = "sign_intermediate";
            Action["SIGN_CSR"] = "sign_csr";
            Action["SET_SIGNED"] = "set_signed";
            Action["REVOKE"] = "revoke";
            Action["ROTATE_CRL"] = "rotate_crl";
        })(Action = ActionOnConfigElementConstants.Action || (ActionOnConfigElementConstants.Action = {}));
    })(ActionOnConfigElementConstants = SecretsManagerV1.ActionOnConfigElementConstants || (SecretsManagerV1.ActionOnConfigElementConstants = {}));
    /** Constants for the `deleteConfigElement` operation. */
    var DeleteConfigElementConstants;
    (function (DeleteConfigElementConstants) {
        /** The secret type. */
        var SecretType;
        (function (SecretType) {
            SecretType["PUBLIC_CERT"] = "public_cert";
            SecretType["PRIVATE_CERT"] = "private_cert";
        })(SecretType = DeleteConfigElementConstants.SecretType || (DeleteConfigElementConstants.SecretType = {}));
        /** The configuration element to define or manage. */
        var ConfigElement;
        (function (ConfigElement) {
            ConfigElement["CERTIFICATE_AUTHORITIES"] = "certificate_authorities";
            ConfigElement["DNS_PROVIDERS"] = "dns_providers";
            ConfigElement["ROOT_CERTIFICATE_AUTHORITIES"] = "root_certificate_authorities";
            ConfigElement["INTERMEDIATE_CERTIFICATE_AUTHORITIES"] = "intermediate_certificate_authorities";
            ConfigElement["CERTIFICATE_TEMPLATES"] = "certificate_templates";
        })(ConfigElement = DeleteConfigElementConstants.ConfigElement || (DeleteConfigElementConstants.ConfigElement = {}));
    })(DeleteConfigElementConstants = SecretsManagerV1.DeleteConfigElementConstants || (SecretsManagerV1.DeleteConfigElementConstants = {}));
})(SecretsManagerV1 || (SecretsManagerV1 = {}));
module.exports = SecretsManagerV1;
//# sourceMappingURL=v1.js.map