"use strict";
/**
 * (C) Copyright IBM Corp. 2023.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
/**
 * IBM OpenAPI SDK Code Generator Version: 3.69.0-370d6400-20230329-174648
 */
/* eslint-disable max-classes-per-file */
/* eslint-disable no-await-in-loop */
var extend = require("extend");
var ibm_cloud_sdk_core_1 = require("ibm-cloud-sdk-core");
var ibm_cloud_sdk_core_2 = require("ibm-cloud-sdk-core");
var common_1 = require("../lib/common");
var ibm_cloud_sdk_core_3 = require("ibm-cloud-sdk-core");
/**
 * With IBM CloudÂ® Secrets Manager, you can create, lease, and centrally manage secrets that are used in IBM Cloud
 * services or your custom-built applications.
 *
 * API Version: 2.0.0
 * See: https://cloud.ibm.com/docs/secrets-manager
 */
var SecretsManagerV2 = /** @class */ (function (_super) {
    __extends(SecretsManagerV2, _super);
    /**
     * Construct a SecretsManagerV2 object.
     *
     * @param {Object} options - Options for the service.
     * @param {string} [options.serviceUrl] - The base url to use when contacting the service. The base url may differ between IBM Cloud regions.
     * @param {OutgoingHttpHeaders} [options.headers] - Default headers that shall be included with every request to the service.
     * @param {Authenticator} options.authenticator - The Authenticator object used to authenticate requests to the service
     * @constructor
     * @returns {SecretsManagerV2}
     */
    function SecretsManagerV2(options) {
        var _this = this;
        options = options || {};
        _this = _super.call(this, options) || this;
        if (options.serviceUrl) {
            _this.setServiceUrl(options.serviceUrl);
        }
        else {
            _this.setServiceUrl(SecretsManagerV2.DEFAULT_SERVICE_URL);
        }
        return _this;
    }
    /**
     * Constructs a service URL by formatting the parameterized service URL.
     *
     * The parameterized service URL is:
     * 'https://{instance_id}.{region}.secrets-manager.appdomain.cloud'
     *
     * The default variable values are:
     * - 'instance_id': 'provide-here-your-smgr-instanceuuid'
     * - 'region': 'us-south'
     *
     * @param {Map<string, string>} | null providedUrlVariables Map from variable names to desired values.
     *  If a variable is not provided in this map,
     *  the default variable value will be used instead.
     * @returns {string} The formatted URL with all variable placeholders replaced by values.
     */
    SecretsManagerV2.constructServiceUrl = function (providedUrlVariables) {
        return (0, ibm_cloud_sdk_core_2.constructServiceUrl)(SecretsManagerV2.PARAMETERIZED_SERVICE_URL, SecretsManagerV2.defaultUrlVariables, providedUrlVariables);
    };
    /*************************
     * Factory method
     ************************/
    /**
     * Constructs an instance of SecretsManagerV2 with passed in options and external configuration.
     *
     * @param {UserOptions} [options] - The parameters to send to the service.
     * @param {string} [options.serviceName] - The name of the service to configure
     * @param {Authenticator} [options.authenticator] - The Authenticator object used to authenticate requests to the service
     * @param {string} [options.serviceUrl] - The URL for the service
     * @returns {SecretsManagerV2}
     */
    SecretsManagerV2.newInstance = function (options) {
        options = options || {};
        if (!options.serviceName) {
            options.serviceName = this.DEFAULT_SERVICE_NAME;
        }
        if (!options.authenticator) {
            options.authenticator = (0, ibm_cloud_sdk_core_1.getAuthenticatorFromEnvironment)(options.serviceName);
        }
        var service = new SecretsManagerV2(options);
        service.configureService(options.serviceName);
        if (options.serviceUrl) {
            service.setServiceUrl(options.serviceUrl);
        }
        return service;
    };
    /*************************
     * secretGroups
     ************************/
    /**
     * Create a new secret group.
     *
     * Create a secret group that you can use to organize secrets and control who can access them.
     *
     * A successful request returns the ID value of the secret group, along with other properties. To learn more about
     * secret groups, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-secret-groups).
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.name - The name of your secret group.
     * @param {string} [params.description] - An extended description of your secret group.
     *
     * To protect your privacy, do not use personal data, such as your name or location, as a description for your secret
     * group.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretGroup>>}
     */
    SecretsManagerV2.prototype.createSecretGroup = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['name'];
        var _validParams = ['name', 'description', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'name': _params.name,
            'description': _params.description,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createSecretGroup');
        var parameters = {
            options: {
                url: '/api/v2/secret_groups',
                method: 'POST',
                body: body,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List secret groups.
     *
     * List the secret groups that are available in your Secrets Manager instance.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretGroupCollection>>}
     */
    SecretsManagerV2.prototype.listSecretGroups = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'listSecretGroups');
        var parameters = {
            options: {
                url: '/api/v2/secret_groups',
                method: 'GET',
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get a secret group.
     *
     * Get the properties of an existing secret group by specifying the ID of the group.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret group.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretGroup>>}
     */
    SecretsManagerV2.prototype.getSecretGroup = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'getSecretGroup');
        var parameters = {
            options: {
                url: '/api/v2/secret_groups/{id}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Update a secret group.
     *
     * Update the properties of an existing secret group, such as its name or description.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret group.
     * @param {string} [params.name] - The name of your secret group.
     * @param {string} [params.description] - An extended description of your secret group.
     *
     * To protect your privacy, do not use personal data, such as your name or location, as a description for your secret
     * group.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretGroup>>}
     */
    SecretsManagerV2.prototype.updateSecretGroup = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'name', 'description', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'name': _params.name,
            'description': _params.description,
        };
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'updateSecretGroup');
        var parameters = {
            options: {
                url: '/api/v2/secret_groups/{id}',
                method: 'PATCH',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/merge-patch+json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete a secret group.
     *
     * Delete a secret group by specifying the ID of the secret group.
     *
     * **Note:** To delete a secret group, it must be empty. If you need to remove a secret group that contains secrets,
     * you must first [delete the secrets](#delete-secret) that are associated with the group.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret group.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.EmptyObject>>}
     */
    SecretsManagerV2.prototype.deleteSecretGroup = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'deleteSecretGroup');
        var parameters = {
            options: {
                url: '/api/v2/secret_groups/{id}',
                method: 'DELETE',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * secrets
     ************************/
    /**
     * Create a new secret.
     *
     * Create a secret or import an existing value that you can use to access or authenticate to a protected resource.
     *
     * Use this operation to either generate or import an existing secret, such as a TLS certificate, that you can manage
     * in your Secrets Manager service instance. A successful request stores the secret in your dedicated instance, based
     * on the secret type and data that you specify. The response returns the ID value of the secret, along with other
     * metadata.
     *
     * To learn more about the types of secrets that you can create with Secrets Manager, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-what-is-secret).
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {SecretPrototype} params.secretPrototype -
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.Secret>>}
     */
    SecretsManagerV2.prototype.createSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretPrototype'];
        var _validParams = ['secretPrototype', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.secretPrototype;
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createSecret');
        var parameters = {
            options: {
                url: '/api/v2/secrets',
                method: 'POST',
                body: body,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List secrets.
     *
     * List the secrets that are available in your Secrets Manager instance.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {number} [params.offset] - The number of secrets to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 secrets in your instance, and you want to retrieve secrets 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {number} [params.limit] - The number of secrets to retrieve. By default, list operations return the first
     * 200 items. To retrieve a different set of items, use `limit` with `offset` to page through your available
     * resources. Maximum limit allowed is 1000 secrets.
     *
     * **Usage:** If you want to retrieve only the first 25 secrets in your instance, use
     * `..?limit=25`.
     * @param {string} [params.sort] - Sort a collection of secrets by the specified field in ascending order. To sort in
     * descending order use the `-` character
     *
     *
     * **Available values:** id | created_at | updated_at | expiration_date | secret_type | name
     *
     * **Usage:** To sort a list of secrets by their creation date, use
     * `../secrets?sort=created_at`.
     * @param {string} [params.search] - Obtain a collection of secrets that contain the specified string in one or more
     * of the fields: `id`, `name`, `description`,
     * `labels`, `secret_type`.
     *
     * **Usage:** If you want to list only the secrets that contain the string `text`, use
     * `../secrets?search=text`.
     * @param {string[]} [params.groups] - Filter secrets by groups.
     *
     * You can apply multiple filters by using a comma-separated list of secret group IDs. If you need to filter secrets
     * that are in the default secret group, use the `default` keyword.
     *
     * **Usage:** To retrieve a list of secrets that are associated with an existing secret group or the default group,
     * use `..?groups={secret_group_ID},default`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretMetadataPaginatedCollection>>}
     */
    SecretsManagerV2.prototype.listSecrets = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['offset', 'limit', 'sort', 'search', 'groups', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'offset': _params.offset,
            'limit': _params.limit,
            'sort': _params.sort,
            'search': _params.search,
            'groups': _params.groups,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'listSecrets');
        var parameters = {
            options: {
                url: '/api/v2/secrets',
                method: 'GET',
                qs: query,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get a secret.
     *
     * Get a secret and its details by specifying the ID of the secret.
     *
     * A successful request returns the secret data that is associated with your secret, along with other metadata. To
     * view only the details of a specified secret without retrieving its value, use the [Get secret
     * metadata](#get-secret-metadata) operation.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.Secret>>}
     */
    SecretsManagerV2.prototype.getSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'getSecret');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{id}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete a secret.
     *
     * Delete a secret by specifying the ID of the secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.EmptyObject>>}
     */
    SecretsManagerV2.prototype.deleteSecret = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'deleteSecret');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{id}',
                method: 'DELETE',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get the metadata of a secret.
     *
     * Get the metadata of a secret by specifying the ID of the secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretMetadata>>}
     */
    SecretsManagerV2.prototype.getSecretMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'getSecretMetadata');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{id}/metadata',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Update the metadata of a secret.
     *
     * Update the metadata of a secret, such as its name or description.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret.
     * @param {SecretMetadataPatch} params.secretMetadataPatch -
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretMetadata>>}
     */
    SecretsManagerV2.prototype.updateSecretMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id', 'secretMetadataPatch'];
        var _validParams = ['id', 'secretMetadataPatch', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.secretMetadataPatch;
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'updateSecretMetadata');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{id}/metadata',
                method: 'PATCH',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/merge-patch+json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Create a secret action.
     *
     * Create a secret action. This operation supports the following actions:.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret.
     * @param {SecretActionPrototype} params.secretActionPrototype -
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretAction>>}
     */
    SecretsManagerV2.prototype.createSecretAction = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id', 'secretActionPrototype'];
        var _validParams = ['id', 'secretActionPrototype', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.secretActionPrototype;
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createSecretAction');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{id}/actions',
                method: 'POST',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * secretVersions
     ************************/
    /**
     * Create a new secret version.
     *
     * Create a new secret version.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {SecretVersionPrototype} params.secretVersionPrototype -
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretVersion>>}
     */
    SecretsManagerV2.prototype.createSecretVersion = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'secretVersionPrototype'];
        var _validParams = ['secretId', 'secretVersionPrototype', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.secretVersionPrototype;
        var path = {
            'secret_id': _params.secretId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createSecretVersion');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions',
                method: 'POST',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List versions of a secret.
     *
     * List the versions of a secret.
     *
     * A successful request returns the list of versions of a secret, along with the metadata of each version.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretVersionMetadataCollection>>}
     */
    SecretsManagerV2.prototype.listSecretVersions = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId'];
        var _validParams = ['secretId', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_id': _params.secretId,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'listSecretVersions');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get a version of a secret.
     *
     * Get a version of a secret by specifying the ID of the version. You can use the `current` or `previous` aliases to
     * refer to the current or previous secret version.
     *
     * A successful request returns the secret data that is associated with the specified version of your secret, along
     * with other metadata.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret version. You can use the `current` or
     * `previous` aliases to refer to the current or previous secret version.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretVersion>>}
     */
    SecretsManagerV2.prototype.getSecretVersion = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'id'];
        var _validParams = ['secretId', 'id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_id': _params.secretId,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'getSecretVersion');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions/{id}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete the data of a secret version.
     *
     * Delete the data of a secret version by specifying the ID of the version.
     *
     * This operation is available for secret type: iam_credentials current version.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret version. You can use the `current` or
     * `previous` aliases to refer to the current or previous secret version.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.EmptyObject>>}
     */
    SecretsManagerV2.prototype.deleteSecretVersionData = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'id'];
        var _validParams = ['secretId', 'id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_id': _params.secretId,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'deleteSecretVersionData');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions/{id}/secret_data',
                method: 'DELETE',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get the metadata of a secret version.
     *
     * Get the metadata of a secret version by specifying the ID of the version. You can use the `current` or `previous`
     * aliases to refer to the current or previous secret version.
     *
     * A successful request returns the metadata that is associated with the specified version of your secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret version. You can use the `current` or
     * `previous` aliases to refer to the current or previous secret version.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretVersionMetadata>>}
     */
    SecretsManagerV2.prototype.getSecretVersionMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'id'];
        var _validParams = ['secretId', 'id', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'secret_id': _params.secretId,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'getSecretVersionMetadata');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions/{id}/metadata',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Update the metadata of a secret version.
     *
     * Update the custom metadata of a secret version.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret version. You can use the `current` or
     * `previous` aliases to refer to the current or previous secret version.
     * @param {JsonObject} [params.versionCustomMetadata] - The secret version metadata that a user can customize.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretVersionMetadata>>}
     */
    SecretsManagerV2.prototype.updateSecretVersionMetadata = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'id'];
        var _validParams = ['secretId', 'id', 'versionCustomMetadata', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'version_custom_metadata': _params.versionCustomMetadata,
        };
        var path = {
            'secret_id': _params.secretId,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'updateSecretVersionMetadata');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions/{id}/metadata',
                method: 'PATCH',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/merge-patch+json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Create a version action.
     *
     * Create a secret version action. This operation supports the following actions:
     *
     * - `private_cert_action_revoke_certificate`: Revoke a version of a private certificate.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret version. You can use the `current` or
     * `previous` aliases to refer to the current or previous secret version.
     * @param {SecretVersionActionPrototype} params.secretVersionActionPrototype -
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.VersionAction>>}
     */
    SecretsManagerV2.prototype.createSecretVersionAction = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'id', 'secretVersionActionPrototype'];
        var _validParams = ['secretId', 'id', 'secretVersionActionPrototype', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.secretVersionActionPrototype;
        var path = {
            'secret_id': _params.secretId,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createSecretVersionAction');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions/{id}/actions',
                method: 'POST',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * secretLocks
     ************************/
    /**
     * List secrets and their locks.
     *
     * List the secrets and their locks in your Secrets Manager instance.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {number} [params.offset] - The number of secrets to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 secrets in your instance, and you want to retrieve secrets 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {number} [params.limit] - The number of secrets to retrieve. By default, list operations return the first
     * 200 items. To retrieve a different set of items, use `limit` with `offset` to page through your available
     * resources. Maximum limit allowed is 1000 secrets.
     *
     * **Usage:** If you want to retrieve only the first 25 secrets in your instance, use
     * `..?limit=25`.
     * @param {string} [params.search] - Filter locks that contain the specified string in the field "name".
     *
     * **Usage:** If you want to list only the locks that contain the string "text" in the field "name", use
     * `..?search=text`.
     * @param {string[]} [params.groups] - Filter secrets by groups.
     *
     * You can apply multiple filters by using a comma-separated list of secret group IDs. If you need to filter secrets
     * that are in the default secret group, use the `default` keyword.
     *
     * **Usage:** To retrieve a list of secrets that are associated with an existing secret group or the default group,
     * use `..?groups={secret_group_ID},default`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretsLocksPaginatedCollection>>}
     */
    SecretsManagerV2.prototype.listSecretsLocks = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['offset', 'limit', 'search', 'groups', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'offset': _params.offset,
            'limit': _params.limit,
            'search': _params.search,
            'groups': _params.groups,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'listSecretsLocks');
        var parameters = {
            options: {
                url: '/api/v2/secrets_locks',
                method: 'GET',
                qs: query,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List secret locks.
     *
     * List the locks that are associated with a specified secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret.
     * @param {number} [params.offset] - The number of locks to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 locks on your secret, and you want to retrieve locks 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {number} [params.limit] - The number of locks with associated secret to retrieve. By default, list
     * operations return the first 25 items. To retrieve a different set of items, use `limit` with `offset` to page
     * through your available resources.
     *
     * **Usage:** If you have 20 secrets in your instance, and you want to retrieve only the first 5, use
     * `..?limit=5`.
     * @param {string} [params.sort] - Sort a collection of locks by the specified field in ascending order. To sort in
     * descending order use the `-` character
     *
     * **Available values:** created_at | updated_at | name
     *
     * **Usage:** To sort a list of locks by their creation date, use
     * `../locks?sort=created_at`.
     * @param {string} [params.search] - Filter locks that contain the specified string in the field "name".
     *
     * **Usage:** If you want to list only the locks that contain the string "text" in the field "name", use
     * `..?search=text`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretLocksPaginatedCollection>>}
     */
    SecretsManagerV2.prototype.listSecretLocks = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'offset', 'limit', 'sort', 'search', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'offset': _params.offset,
            'limit': _params.limit,
            'sort': _params.sort,
            'search': _params.search,
        };
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'listSecretLocks');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{id}/locks',
                method: 'GET',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Create secret locks.
     *
     * Create a lock on the current version of a secret.
     *
     * A lock can be used to prevent a secret from being deleted or modified while it's in use by your applications. A
     * successful request attaches a new lock to your secret, or replaces a lock of the same name if it already exists.
     * Additionally, you can use this operation to clear any matching locks on a secret by using one of the following
     * optional lock modes:
     *
     * - `remove_previous`: Removes any other locks with matching names if they are found in the previous version of the
     * secret.\n
     * - `remove_previous_and_delete`: Carries out the same function as `remove_previous`, but also permanently deletes
     * the data of the previous secret version if it doesn't have any locks.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret.
     * @param {SecretLockPrototype[]} params.locks - The locks data to be attached to a secret version.
     * @param {string} [params.mode] - An optional lock mode. When you create a lock, you can set one of the following
     * modes to clear any matching locks on a secret version.
     * - `remove_previous`: Removes any other locks with matching names if they are found in the previous version of the
     * secret. - `remove_previous_and_delete`: Completes the same action as `remove_previous`, but also permanently
     * deletes the data of the previous secret version if it doesn't have any locks.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretLocks>>}
     */
    SecretsManagerV2.prototype.createSecretLocksBulk = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id', 'locks'];
        var _validParams = ['id', 'locks', 'mode', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'locks': _params.locks,
        };
        var query = {
            'mode': _params.mode,
        };
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createSecretLocksBulk');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{id}/locks_bulk',
                method: 'POST',
                body: body,
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete secret locks.
     *
     * Delete all the locks or a subset of the locks that are associated with a version of a secret.
     *
     * To delete only a subset of the locks, add a query param with a comma to separate the list of lock names:
     *
     * Example: `?name=lock-example-1,lock-example-2`.
     *
     * **Note:** A secret is considered unlocked and able to be deleted only after you remove all of its locks. To
     * determine whether a secret contains locks, check the `locks_total` field that is returned as part of the metadata
     * of your secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret.
     * @param {string[]} [params.name] - Specify the names of the secret locks to be deleted.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretLocks>>}
     */
    SecretsManagerV2.prototype.deleteSecretLocksBulk = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['id'];
        var _validParams = ['id', 'name', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'name': _params.name,
        };
        var path = {
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'deleteSecretLocksBulk');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{id}/locks_bulk',
                method: 'DELETE',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List secret version locks.
     *
     * List the locks that are associated with a specified secret version.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret version. You can use the `current` or
     * `previous` aliases to refer to the current or previous secret version.
     * @param {number} [params.offset] - The number of locks to skip. By specifying `offset`, you retrieve a subset of
     * items that starts with the `offset` value. Use `offset` with `limit` to page through your available resources.
     *
     * **Usage:** If you have 100 locks on your secret, and you want to retrieve locks 26 through 50, use
     * `..?offset=25&limit=25`.
     * @param {number} [params.limit] - The number of locks with associated secret to retrieve. By default, list
     * operations return the first 25 items. To retrieve a different set of items, use `limit` with `offset` to page
     * through your available resources.
     *
     * **Usage:** If you have 20 secrets in your instance, and you want to retrieve only the first 5, use
     * `..?limit=5`.
     * @param {string} [params.sort] - Sort a collection of locks by the specified field in ascending order. To sort in
     * descending order use the `-` character
     *
     * **Available values:** created_at | updated_at | name
     *
     * **Usage:** To sort a list of locks by their creation date, use
     * `../locks?sort=created_at`.
     * @param {string} [params.search] - Filter locks that contain the specified string in the field "name".
     *
     * **Usage:** If you want to list only the locks that contain the string "text" in the field "name", use
     * `..?search=text`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretVersionLocksPaginatedCollection>>}
     */
    SecretsManagerV2.prototype.listSecretVersionLocks = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'id'];
        var _validParams = ['secretId', 'id', 'offset', 'limit', 'sort', 'search', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'offset': _params.offset,
            'limit': _params.limit,
            'sort': _params.sort,
            'search': _params.search,
        };
        var path = {
            'secret_id': _params.secretId,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'listSecretVersionLocks');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions/{id}/locks',
                method: 'GET',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Create secret version locks.
     *
     * Create a lock on the specified version of a secret.
     *
     * A lock can be used to prevent a secret from being deleted or modified while it's in use by your applications. A
     * successful request attaches a new lock to your secret, or replaces a lock of the same name if it already exists.
     * Additionally, you can use this operation to clear any matching locks on a secret by using one of the following
     * optional lock modes:
     *
     * - `remove_previous`: Removes any other locks with matching names if they are found in the previous version of the
     * secret.
     * - `remove_previous_and_delete`: Carries out the same function as `remove_previous`, but also permanently deletes
     * the data of the previous secret version if it doesn't have any locks.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret version. You can use the `current` or
     * `previous` aliases to refer to the current or previous secret version.
     * @param {SecretLockPrototype[]} params.locks - The locks data to be attached to a secret version.
     * @param {string} [params.mode] - An optional lock mode. When you create a lock, you can set one of the following
     * modes to clear any matching locks on a secret version.
     * - `remove_previous`: Removes any other locks with matching names if they are found in the previous version of the
     * secret. - `remove_previous_and_delete`: Completes the same action as `remove_previous`, but also permanently
     * deletes the data of the previous secret version if it doesn't have any locks.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretLocks>>}
     */
    SecretsManagerV2.prototype.createSecretVersionLocksBulk = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'id', 'locks'];
        var _validParams = ['secretId', 'id', 'locks', 'mode', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'locks': _params.locks,
        };
        var query = {
            'mode': _params.mode,
        };
        var path = {
            'secret_id': _params.secretId,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createSecretVersionLocksBulk');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions/{id}/locks_bulk',
                method: 'POST',
                body: body,
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete locks on a secret version.
     *
     * Delete all the locks or a subset of the locks that are associated with the specified version of a secret.
     *
     * To delete only a subset of the locks, add a query param with a comma to separate the list of lock names:
     *
     * Example: `?name=lock-example-1,lock-example-2`.
     *
     * **Note:** A secret is considered unlocked and able to be deleted only after all of its locks are removed. To
     * determine whether a secret contains locks, check the `locks_total` field that is returned as part of the metadata
     * of your secret.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.secretId - The v4 UUID that uniquely identifies your secret.
     * @param {string} params.id - The v4 UUID that uniquely identifies your secret version. You can use the `current` or
     * `previous` aliases to refer to the current or previous secret version.
     * @param {string[]} [params.name] - Specify the names of the secret locks to be deleted.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.SecretLocks>>}
     */
    SecretsManagerV2.prototype.deleteSecretVersionLocksBulk = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['secretId', 'id'];
        var _validParams = ['secretId', 'id', 'name', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'name': _params.name,
        };
        var path = {
            'secret_id': _params.secretId,
            'id': _params.id,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'deleteSecretVersionLocksBulk');
        var parameters = {
            options: {
                url: '/api/v2/secrets/{secret_id}/versions/{id}/locks_bulk',
                method: 'DELETE',
                qs: query,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * configurations
     ************************/
    /**
     * Create a new configuration.
     *
     * Add a configuration to the specified secret type.
     *
     * Use this operation to define the configurations that are required to create public certificates (`public_cert`),
     * private certificates (`private_cert`) and IAM Credentials secrets (`iam_credentials`).
     *
     * You can add multiple configurations for your instance as follows:
     *
     * - A single configuration for IAM Credentials.
     * - Up to 10 CA configurations for public certificates.
     * - Up to 10 DNS configurations for public certificates.
     * - Up to 10 Root CA configurations for private certificates.
     * - Up to 10 Intermediate CA configurations for private certificates.
     * - Up to 10 Certificate Template configurations for private certificates.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {ConfigurationPrototype} params.configurationPrototype -
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.Configuration>>}
     */
    SecretsManagerV2.prototype.createConfiguration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['configurationPrototype'];
        var _validParams = ['configurationPrototype', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.configurationPrototype;
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createConfiguration');
        var parameters = {
            options: {
                url: '/api/v2/configurations',
                method: 'POST',
                body: body,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * List configurations.
     *
     * List the configurations that are available in your Secrets Manager instance.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {number} [params.offset] - The number of configurations to skip. By specifying `offset`, you retrieve a
     * subset of items that starts with the `offset` value. Use `offset` with `limit` to page through your available
     * resources.
     *
     * **Usage:** If you have 100 configurations in your instance, and you want to retrieve configurations 26 through 50,
     * use
     * `..?offset=25&limit=25`.
     * @param {number} [params.limit] - The number of configurations to retrieve. By default, list operations return the
     * first 200 items. To retrieve a different set of items, use `limit` with `offset` to page through your available
     * resources. Maximum limit allowed is 1000 secrets.
     *
     * **Usage:** If you want to retrieve only the first 25 configurations in your instance, use
     * `..?limit=25`.
     * @param {string} [params.sort] - Sort a collection of configurations by the specified field in ascending order. To
     * sort in descending order use the `-` character
     *
     *
     * **Available values:**  config_type | secret_type | name
     *
     * **Usage:** To sort a list of configurations by their creation date, use
     * `../configurations?sort=config_type`.
     * @param {string} [params.search] - Obtain a collection of configurations that contain the specified string in one or
     * more of the fields: `name`, `config_type`, `secret_type`.
     *
     * **Usage:** If you want to list only the configurations that contain the string `text`, use
     * `../secrets?search=text`.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.ConfigurationMetadataPaginatedCollection>>}
     */
    SecretsManagerV2.prototype.listConfigurations = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['offset', 'limit', 'sort', 'search', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var query = {
            'offset': _params.offset,
            'limit': _params.limit,
            'sort': _params.sort,
            'search': _params.search,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'listConfigurations');
        var parameters = {
            options: {
                url: '/api/v2/configurations',
                method: 'GET',
                qs: query,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get a configuration.
     *
     * Get a configuration by specifying its name.
     *
     * A successful request returns the details of your configuration.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.name - The name that uniquely identifies a configuration.
     * @param {string} [params.xSmAcceptConfigurationType] - The configuration type of this configuration - use this
     * header to resolve 300 error responses.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.Configuration>>}
     */
    SecretsManagerV2.prototype.getConfiguration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['name'];
        var _validParams = ['name', 'xSmAcceptConfigurationType', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'name': _params.name,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'getConfiguration');
        var parameters = {
            options: {
                url: '/api/v2/configurations/{name}',
                method: 'GET',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'X-Sm-Accept-Configuration-Type': _params.xSmAcceptConfigurationType,
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Update configuration.
     *
     * Update a configuration.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.name - The name that uniquely identifies a configuration.
     * @param {ConfigurationPatch} params.configurationPatch -
     * @param {string} [params.xSmAcceptConfigurationType] - The configuration type of this configuration - use this
     * header to resolve 300 error responses.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.Configuration>>}
     */
    SecretsManagerV2.prototype.updateConfiguration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['name', 'configurationPatch'];
        var _validParams = ['name', 'configurationPatch', 'xSmAcceptConfigurationType', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.configurationPatch;
        var path = {
            'name': _params.name,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'updateConfiguration');
        var parameters = {
            options: {
                url: '/api/v2/configurations/{name}',
                method: 'PATCH',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/merge-patch+json',
                    'X-Sm-Accept-Configuration-Type': _params.xSmAcceptConfigurationType,
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Delete a configuration.
     *
     * Delete a configuration by specifying its name.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.name - The name that uniquely identifies a configuration.
     * @param {string} [params.xSmAcceptConfigurationType] - The configuration type of this configuration - use this
     * header to resolve 300 error responses.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.EmptyObject>>}
     */
    SecretsManagerV2.prototype.deleteConfiguration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['name'];
        var _validParams = ['name', 'xSmAcceptConfigurationType', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var path = {
            'name': _params.name,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'deleteConfiguration');
        var parameters = {
            options: {
                url: '/api/v2/configurations/{name}',
                method: 'DELETE',
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'X-Sm-Accept-Configuration-Type': _params.xSmAcceptConfigurationType,
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Create a configuration action.
     *
     * Create a configuration action. This operation supports the following actions:
     *
     * - `private_cert_configuration_action_sign_intermediate`: Sign an intermediate certificate authority.
     * - `private_cert_configuration_action_sign_csr`: Sign a certificate signing request.
     * - `private_cert_configuration_action_set_signed`: Set a signed intermediate certificate authority.
     * - `private_cert_configuration_action_revoke_ca_certificate`: Revoke an internally signed intermediate certificate
     * authority certificate.
     * - `private_cert_configuration_action_rotate_crl`: Rotate the certificate revocation list (CRL) of an intermediate
     * certificate authority.
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.name - The name that uniquely identifies a configuration.
     * @param {ConfigurationActionPrototype} params.configActionPrototype -
     * @param {string} [params.xSmAcceptConfigurationType] - The configuration type of this configuration - use this
     * header to resolve 300 error responses.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.ConfigurationAction>>}
     */
    SecretsManagerV2.prototype.createConfigurationAction = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['name', 'configActionPrototype'];
        var _validParams = ['name', 'configActionPrototype', 'xSmAcceptConfigurationType', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = _params.configActionPrototype;
        var path = {
            'name': _params.name,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createConfigurationAction');
        var parameters = {
            options: {
                url: '/api/v2/configurations/{name}/actions',
                method: 'POST',
                body: body,
                path: path,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                    'X-Sm-Accept-Configuration-Type': _params.xSmAcceptConfigurationType,
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /*************************
     * notifications
     ************************/
    /**
     * Register with Event Notifications instance.
     *
     * Create a registration between a Secrets Manager instance and [Event
     * Notifications](https://cloud.ibm.com/apidocs/event-notifications).
     *
     * A successful request adds Secrets Manager as a source that you can reference from your Event Notifications
     * instance. For more information about enabling notifications for Secrets Manager, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-event-notifications).
     *
     * @param {Object} params - The parameters to send to the service.
     * @param {string} params.eventNotificationsInstanceCrn - A CRN that uniquely identifies an IBM Cloud resource.
     * @param {string} params.eventNotificationsSourceName - The name that is displayed as a source that is in your Event
     * Notifications instance.
     * @param {string} [params.eventNotificationsSourceDescription] - An optional description for the source that is in
     * your Event Notifications instance.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.NotificationsRegistration>>}
     */
    SecretsManagerV2.prototype.createNotificationsRegistration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = ['eventNotificationsInstanceCrn', 'eventNotificationsSourceName'];
        var _validParams = ['eventNotificationsInstanceCrn', 'eventNotificationsSourceName', 'eventNotificationsSourceDescription', 'headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var body = {
            'event_notifications_instance_crn': _params.eventNotificationsInstanceCrn,
            'event_notifications_source_name': _params.eventNotificationsSourceName,
            'event_notifications_source_description': _params.eventNotificationsSourceDescription,
        };
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'createNotificationsRegistration');
        var parameters = {
            options: {
                url: '/api/v2/notifications/registration',
                method: 'POST',
                body: body,
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Get Event Notifications registration details.
     *
     * Get the details of the registration between your Secrets Manager instance and Event Notifications.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.NotificationsRegistration>>}
     */
    SecretsManagerV2.prototype.getNotificationsRegistration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'getNotificationsRegistration');
        var parameters = {
            options: {
                url: '/api/v2/notifications/registration',
                method: 'GET',
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {
                    'Accept': 'application/json',
                }, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Unregister from Event Notifications instance.
     *
     * Delete the registration between your Secrets Manager instance and Event Notifications.
     *
     * A successful request removes your Secrets Manager instance as a source in Event Notifications.
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.EmptyObject>>}
     */
    SecretsManagerV2.prototype.deleteNotificationsRegistration = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'deleteNotificationsRegistration');
        var parameters = {
            options: {
                url: '/api/v2/notifications/registration',
                method: 'DELETE',
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    /**
     * Send a test event for Event Notifications registrations.
     *
     * Send a test event from a Secrets Manager instance to a configured [Event
     * Notifications](https://cloud.ibm.com/apidocs/event-notifications) instance.
     *
     * A successful request sends a test event to the Event Notifications instance. For more information about enabling
     * notifications for Secrets Manager, check out the
     * [docs](https://cloud.ibm.com/docs/secrets-manager?topic=secrets-manager-event-notifications).
     *
     * @param {Object} [params] - The parameters to send to the service.
     * @param {OutgoingHttpHeaders} [params.headers] - Custom request headers
     * @returns {Promise<SecretsManagerV2.Response<SecretsManagerV2.EmptyObject>>}
     */
    SecretsManagerV2.prototype.getNotificationsRegistrationTest = function (params) {
        var _params = __assign({}, params);
        var _requiredParams = [];
        var _validParams = ['headers'];
        var _validationErrors = (0, ibm_cloud_sdk_core_1.validateParams)(_params, _requiredParams, _validParams);
        if (_validationErrors) {
            return Promise.reject(_validationErrors);
        }
        var sdkHeaders = (0, common_1.getSdkHeaders)(SecretsManagerV2.DEFAULT_SERVICE_NAME, 'v2', 'getNotificationsRegistrationTest');
        var parameters = {
            options: {
                url: '/api/v2/notifications/registration/test',
                method: 'GET',
            },
            defaultOptions: extend(true, {}, this.baseOptions, {
                headers: extend(true, sdkHeaders, {}, _params.headers),
            }),
        };
        return this.createRequest(parameters);
    };
    SecretsManagerV2.DEFAULT_SERVICE_URL = 'https://provide-here-your-smgr-instanceuuid.us-south.secrets-manager.appdomain.cloud';
    SecretsManagerV2.DEFAULT_SERVICE_NAME = 'secrets_manager';
    SecretsManagerV2.PARAMETERIZED_SERVICE_URL = 'https://{instance_id}.{region}.secrets-manager.appdomain.cloud';
    SecretsManagerV2.defaultUrlVariables = new Map([
        ['instance_id', 'provide-here-your-smgr-instanceuuid'],
        ['region', 'us-south'],
    ]);
    return SecretsManagerV2;
}(ibm_cloud_sdk_core_1.BaseService));
/*************************
 * interfaces
 ************************/
(function (SecretsManagerV2) {
    /** Constants for the `createSecretLocksBulk` operation. */
    var CreateSecretLocksBulkConstants;
    (function (CreateSecretLocksBulkConstants) {
        /** An optional lock mode. When you create a lock, you can set one of the following modes to clear any matching locks on a secret version. - `remove_previous`: Removes any other locks with matching names if they are found in the previous version of the secret. - `remove_previous_and_delete`: Completes the same action as `remove_previous`, but also permanently deletes the data of the previous secret version if it doesn't have any locks. */
        var Mode;
        (function (Mode) {
            Mode["REMOVE_PREVIOUS"] = "remove_previous";
            Mode["REMOVE_PREVIOUS_AND_DELETE"] = "remove_previous_and_delete";
        })(Mode = CreateSecretLocksBulkConstants.Mode || (CreateSecretLocksBulkConstants.Mode = {}));
    })(CreateSecretLocksBulkConstants = SecretsManagerV2.CreateSecretLocksBulkConstants || (SecretsManagerV2.CreateSecretLocksBulkConstants = {}));
    /** Constants for the `createSecretVersionLocksBulk` operation. */
    var CreateSecretVersionLocksBulkConstants;
    (function (CreateSecretVersionLocksBulkConstants) {
        /** An optional lock mode. When you create a lock, you can set one of the following modes to clear any matching locks on a secret version. - `remove_previous`: Removes any other locks with matching names if they are found in the previous version of the secret. - `remove_previous_and_delete`: Completes the same action as `remove_previous`, but also permanently deletes the data of the previous secret version if it doesn't have any locks. */
        var Mode;
        (function (Mode) {
            Mode["REMOVE_PREVIOUS"] = "remove_previous";
            Mode["REMOVE_PREVIOUS_AND_DELETE"] = "remove_previous_and_delete";
        })(Mode = CreateSecretVersionLocksBulkConstants.Mode || (CreateSecretVersionLocksBulkConstants.Mode = {}));
    })(CreateSecretVersionLocksBulkConstants = SecretsManagerV2.CreateSecretVersionLocksBulkConstants || (SecretsManagerV2.CreateSecretVersionLocksBulkConstants = {}));
    /** Constants for the `getConfiguration` operation. */
    var GetConfigurationConstants;
    (function (GetConfigurationConstants) {
        /** The configuration type of this configuration - use this header to resolve 300 error responses. */
        var XSmAcceptConfigurationType;
        (function (XSmAcceptConfigurationType) {
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT"] = "public_cert_configuration_ca_lets_encrypt";
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE"] = "public_cert_configuration_dns_classic_infrastructure";
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES"] = "public_cert_configuration_dns_cloud_internet_services";
            XSmAcceptConfigurationType["IAM_CREDENTIALS_CONFIGURATION"] = "iam_credentials_configuration";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_ROOT_CA"] = "private_cert_configuration_root_ca";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA"] = "private_cert_configuration_intermediate_ca";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_TEMPLATE"] = "private_cert_configuration_template";
        })(XSmAcceptConfigurationType = GetConfigurationConstants.XSmAcceptConfigurationType || (GetConfigurationConstants.XSmAcceptConfigurationType = {}));
    })(GetConfigurationConstants = SecretsManagerV2.GetConfigurationConstants || (SecretsManagerV2.GetConfigurationConstants = {}));
    /** Constants for the `updateConfiguration` operation. */
    var UpdateConfigurationConstants;
    (function (UpdateConfigurationConstants) {
        /** The configuration type of this configuration - use this header to resolve 300 error responses. */
        var XSmAcceptConfigurationType;
        (function (XSmAcceptConfigurationType) {
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT"] = "public_cert_configuration_ca_lets_encrypt";
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE"] = "public_cert_configuration_dns_classic_infrastructure";
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES"] = "public_cert_configuration_dns_cloud_internet_services";
            XSmAcceptConfigurationType["IAM_CREDENTIALS_CONFIGURATION"] = "iam_credentials_configuration";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_ROOT_CA"] = "private_cert_configuration_root_ca";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA"] = "private_cert_configuration_intermediate_ca";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_TEMPLATE"] = "private_cert_configuration_template";
        })(XSmAcceptConfigurationType = UpdateConfigurationConstants.XSmAcceptConfigurationType || (UpdateConfigurationConstants.XSmAcceptConfigurationType = {}));
    })(UpdateConfigurationConstants = SecretsManagerV2.UpdateConfigurationConstants || (SecretsManagerV2.UpdateConfigurationConstants = {}));
    /** Constants for the `deleteConfiguration` operation. */
    var DeleteConfigurationConstants;
    (function (DeleteConfigurationConstants) {
        /** The configuration type of this configuration - use this header to resolve 300 error responses. */
        var XSmAcceptConfigurationType;
        (function (XSmAcceptConfigurationType) {
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT"] = "public_cert_configuration_ca_lets_encrypt";
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE"] = "public_cert_configuration_dns_classic_infrastructure";
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES"] = "public_cert_configuration_dns_cloud_internet_services";
            XSmAcceptConfigurationType["IAM_CREDENTIALS_CONFIGURATION"] = "iam_credentials_configuration";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_ROOT_CA"] = "private_cert_configuration_root_ca";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA"] = "private_cert_configuration_intermediate_ca";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_TEMPLATE"] = "private_cert_configuration_template";
        })(XSmAcceptConfigurationType = DeleteConfigurationConstants.XSmAcceptConfigurationType || (DeleteConfigurationConstants.XSmAcceptConfigurationType = {}));
    })(DeleteConfigurationConstants = SecretsManagerV2.DeleteConfigurationConstants || (SecretsManagerV2.DeleteConfigurationConstants = {}));
    /** Constants for the `createConfigurationAction` operation. */
    var CreateConfigurationActionConstants;
    (function (CreateConfigurationActionConstants) {
        /** The configuration type of this configuration - use this header to resolve 300 error responses. */
        var XSmAcceptConfigurationType;
        (function (XSmAcceptConfigurationType) {
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_CA_LETS_ENCRYPT"] = "public_cert_configuration_ca_lets_encrypt";
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_DNS_CLASSIC_INFRASTRUCTURE"] = "public_cert_configuration_dns_classic_infrastructure";
            XSmAcceptConfigurationType["PUBLIC_CERT_CONFIGURATION_DNS_CLOUD_INTERNET_SERVICES"] = "public_cert_configuration_dns_cloud_internet_services";
            XSmAcceptConfigurationType["IAM_CREDENTIALS_CONFIGURATION"] = "iam_credentials_configuration";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_ROOT_CA"] = "private_cert_configuration_root_ca";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_INTERMEDIATE_CA"] = "private_cert_configuration_intermediate_ca";
            XSmAcceptConfigurationType["PRIVATE_CERT_CONFIGURATION_TEMPLATE"] = "private_cert_configuration_template";
        })(XSmAcceptConfigurationType = CreateConfigurationActionConstants.XSmAcceptConfigurationType || (CreateConfigurationActionConstants.XSmAcceptConfigurationType = {}));
    })(CreateConfigurationActionConstants = SecretsManagerV2.CreateConfigurationActionConstants || (SecretsManagerV2.CreateConfigurationActionConstants = {}));
    /*************************
     * pager classes
     ************************/
    /**
     * SecretsPager can be used to simplify the use of listSecrets().
     */
    var SecretsPager = /** @class */ (function () {
        /**
         * Construct a SecretsPager object.
         *
         * @param {SecretsManagerV2}  client - The service client instance used to invoke listSecrets()
         * @param {Object} [params] - The parameters to be passed to listSecrets()
         * @constructor
         * @returns {SecretsPager}
         */
        function SecretsPager(client, params) {
            if (params && params.offset) {
                throw new Error("the params.offset field should not be set");
            }
            this._hasNext = true;
            this.pageContext = { next: undefined };
            this.client = client;
            this.params = JSON.parse(JSON.stringify(params || {}));
        }
        /**
         * Returns true if there are potentially more results to be retrieved by invoking getNext().
         * @returns {boolean}
         */
        SecretsPager.prototype.hasNext = function () {
            return this._hasNext;
        };
        /**
         * Returns the next page of results by invoking listSecrets().
         * @returns {Promise<SecretsManagerV2.SecretMetadata[]>}
         */
        SecretsPager.prototype.getNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var response, result, next;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.hasNext()) {
                                throw new Error('No more results available');
                            }
                            if (this.pageContext.next) {
                                this.params.offset = this.pageContext.next;
                            }
                            return [4 /*yield*/, this.client.listSecrets(this.params)];
                        case 1:
                            response = _a.sent();
                            result = response.result;
                            next = null;
                            if (result && result.next) {
                                if (result.next.href) {
                                    next = (0, ibm_cloud_sdk_core_3.getQueryParam)(result.next.href, 'offset');
                                }
                            }
                            this.pageContext.next = next;
                            if (!this.pageContext.next) {
                                this._hasNext = false;
                            }
                            return [2 /*return*/, result.secrets];
                    }
                });
            });
        };
        /**
         * Returns all results by invoking listSecrets() repeatedly until all pages of results have been retrieved.
         * @returns {Promise<SecretsManagerV2.SecretMetadata[]>}
         */
        SecretsPager.prototype.getAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                var results, nextPage;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            results = [];
                            _a.label = 1;
                        case 1:
                            if (!this.hasNext()) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.getNext()];
                        case 2:
                            nextPage = _a.sent();
                            results.push.apply(results, nextPage);
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/, results];
                    }
                });
            });
        };
        return SecretsPager;
    }());
    SecretsManagerV2.SecretsPager = SecretsPager;
    /**
     * SecretsLocksPager can be used to simplify the use of listSecretsLocks().
     */
    var SecretsLocksPager = /** @class */ (function () {
        /**
         * Construct a SecretsLocksPager object.
         *
         * @param {SecretsManagerV2}  client - The service client instance used to invoke listSecretsLocks()
         * @param {Object} [params] - The parameters to be passed to listSecretsLocks()
         * @constructor
         * @returns {SecretsLocksPager}
         */
        function SecretsLocksPager(client, params) {
            if (params && params.offset) {
                throw new Error("the params.offset field should not be set");
            }
            this._hasNext = true;
            this.pageContext = { next: undefined };
            this.client = client;
            this.params = JSON.parse(JSON.stringify(params || {}));
        }
        /**
         * Returns true if there are potentially more results to be retrieved by invoking getNext().
         * @returns {boolean}
         */
        SecretsLocksPager.prototype.hasNext = function () {
            return this._hasNext;
        };
        /**
         * Returns the next page of results by invoking listSecretsLocks().
         * @returns {Promise<SecretsManagerV2.SecretLocks[]>}
         */
        SecretsLocksPager.prototype.getNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var response, result, next;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.hasNext()) {
                                throw new Error('No more results available');
                            }
                            if (this.pageContext.next) {
                                this.params.offset = this.pageContext.next;
                            }
                            return [4 /*yield*/, this.client.listSecretsLocks(this.params)];
                        case 1:
                            response = _a.sent();
                            result = response.result;
                            next = null;
                            if (result && result.next) {
                                if (result.next.href) {
                                    next = (0, ibm_cloud_sdk_core_3.getQueryParam)(result.next.href, 'offset');
                                }
                            }
                            this.pageContext.next = next;
                            if (!this.pageContext.next) {
                                this._hasNext = false;
                            }
                            return [2 /*return*/, result.secrets_locks];
                    }
                });
            });
        };
        /**
         * Returns all results by invoking listSecretsLocks() repeatedly until all pages of results have been retrieved.
         * @returns {Promise<SecretsManagerV2.SecretLocks[]>}
         */
        SecretsLocksPager.prototype.getAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                var results, nextPage;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            results = [];
                            _a.label = 1;
                        case 1:
                            if (!this.hasNext()) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.getNext()];
                        case 2:
                            nextPage = _a.sent();
                            results.push.apply(results, nextPage);
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/, results];
                    }
                });
            });
        };
        return SecretsLocksPager;
    }());
    SecretsManagerV2.SecretsLocksPager = SecretsLocksPager;
    /**
     * SecretLocksPager can be used to simplify the use of listSecretLocks().
     */
    var SecretLocksPager = /** @class */ (function () {
        /**
         * Construct a SecretLocksPager object.
         *
         * @param {SecretsManagerV2}  client - The service client instance used to invoke listSecretLocks()
         * @param {Object} params - The parameters to be passed to listSecretLocks()
         * @constructor
         * @returns {SecretLocksPager}
         */
        function SecretLocksPager(client, params) {
            if (params && params.offset) {
                throw new Error("the params.offset field should not be set");
            }
            this._hasNext = true;
            this.pageContext = { next: undefined };
            this.client = client;
            this.params = JSON.parse(JSON.stringify(params || {}));
        }
        /**
         * Returns true if there are potentially more results to be retrieved by invoking getNext().
         * @returns {boolean}
         */
        SecretLocksPager.prototype.hasNext = function () {
            return this._hasNext;
        };
        /**
         * Returns the next page of results by invoking listSecretLocks().
         * @returns {Promise<SecretsManagerV2.SecretLock[]>}
         */
        SecretLocksPager.prototype.getNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var response, result, next;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.hasNext()) {
                                throw new Error('No more results available');
                            }
                            if (this.pageContext.next) {
                                this.params.offset = this.pageContext.next;
                            }
                            return [4 /*yield*/, this.client.listSecretLocks(this.params)];
                        case 1:
                            response = _a.sent();
                            result = response.result;
                            next = null;
                            if (result && result.next) {
                                if (result.next.href) {
                                    next = (0, ibm_cloud_sdk_core_3.getQueryParam)(result.next.href, 'offset');
                                }
                            }
                            this.pageContext.next = next;
                            if (!this.pageContext.next) {
                                this._hasNext = false;
                            }
                            return [2 /*return*/, result.locks];
                    }
                });
            });
        };
        /**
         * Returns all results by invoking listSecretLocks() repeatedly until all pages of results have been retrieved.
         * @returns {Promise<SecretsManagerV2.SecretLock[]>}
         */
        SecretLocksPager.prototype.getAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                var results, nextPage;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            results = [];
                            _a.label = 1;
                        case 1:
                            if (!this.hasNext()) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.getNext()];
                        case 2:
                            nextPage = _a.sent();
                            results.push.apply(results, nextPage);
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/, results];
                    }
                });
            });
        };
        return SecretLocksPager;
    }());
    SecretsManagerV2.SecretLocksPager = SecretLocksPager;
    /**
     * SecretVersionLocksPager can be used to simplify the use of listSecretVersionLocks().
     */
    var SecretVersionLocksPager = /** @class */ (function () {
        /**
         * Construct a SecretVersionLocksPager object.
         *
         * @param {SecretsManagerV2}  client - The service client instance used to invoke listSecretVersionLocks()
         * @param {Object} params - The parameters to be passed to listSecretVersionLocks()
         * @constructor
         * @returns {SecretVersionLocksPager}
         */
        function SecretVersionLocksPager(client, params) {
            if (params && params.offset) {
                throw new Error("the params.offset field should not be set");
            }
            this._hasNext = true;
            this.pageContext = { next: undefined };
            this.client = client;
            this.params = JSON.parse(JSON.stringify(params || {}));
        }
        /**
         * Returns true if there are potentially more results to be retrieved by invoking getNext().
         * @returns {boolean}
         */
        SecretVersionLocksPager.prototype.hasNext = function () {
            return this._hasNext;
        };
        /**
         * Returns the next page of results by invoking listSecretVersionLocks().
         * @returns {Promise<SecretsManagerV2.SecretLock[]>}
         */
        SecretVersionLocksPager.prototype.getNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var response, result, next;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.hasNext()) {
                                throw new Error('No more results available');
                            }
                            if (this.pageContext.next) {
                                this.params.offset = this.pageContext.next;
                            }
                            return [4 /*yield*/, this.client.listSecretVersionLocks(this.params)];
                        case 1:
                            response = _a.sent();
                            result = response.result;
                            next = null;
                            if (result && result.next) {
                                if (result.next.href) {
                                    next = (0, ibm_cloud_sdk_core_3.getQueryParam)(result.next.href, 'offset');
                                }
                            }
                            this.pageContext.next = next;
                            if (!this.pageContext.next) {
                                this._hasNext = false;
                            }
                            return [2 /*return*/, result.locks];
                    }
                });
            });
        };
        /**
         * Returns all results by invoking listSecretVersionLocks() repeatedly until all pages of results have been retrieved.
         * @returns {Promise<SecretsManagerV2.SecretLock[]>}
         */
        SecretVersionLocksPager.prototype.getAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                var results, nextPage;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            results = [];
                            _a.label = 1;
                        case 1:
                            if (!this.hasNext()) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.getNext()];
                        case 2:
                            nextPage = _a.sent();
                            results.push.apply(results, nextPage);
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/, results];
                    }
                });
            });
        };
        return SecretVersionLocksPager;
    }());
    SecretsManagerV2.SecretVersionLocksPager = SecretVersionLocksPager;
    /**
     * ConfigurationsPager can be used to simplify the use of listConfigurations().
     */
    var ConfigurationsPager = /** @class */ (function () {
        /**
         * Construct a ConfigurationsPager object.
         *
         * @param {SecretsManagerV2}  client - The service client instance used to invoke listConfigurations()
         * @param {Object} [params] - The parameters to be passed to listConfigurations()
         * @constructor
         * @returns {ConfigurationsPager}
         */
        function ConfigurationsPager(client, params) {
            if (params && params.offset) {
                throw new Error("the params.offset field should not be set");
            }
            this._hasNext = true;
            this.pageContext = { next: undefined };
            this.client = client;
            this.params = JSON.parse(JSON.stringify(params || {}));
        }
        /**
         * Returns true if there are potentially more results to be retrieved by invoking getNext().
         * @returns {boolean}
         */
        ConfigurationsPager.prototype.hasNext = function () {
            return this._hasNext;
        };
        /**
         * Returns the next page of results by invoking listConfigurations().
         * @returns {Promise<SecretsManagerV2.ConfigurationMetadata[]>}
         */
        ConfigurationsPager.prototype.getNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var response, result, next;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.hasNext()) {
                                throw new Error('No more results available');
                            }
                            if (this.pageContext.next) {
                                this.params.offset = this.pageContext.next;
                            }
                            return [4 /*yield*/, this.client.listConfigurations(this.params)];
                        case 1:
                            response = _a.sent();
                            result = response.result;
                            next = null;
                            if (result && result.next) {
                                if (result.next.href) {
                                    next = (0, ibm_cloud_sdk_core_3.getQueryParam)(result.next.href, 'offset');
                                }
                            }
                            this.pageContext.next = next;
                            if (!this.pageContext.next) {
                                this._hasNext = false;
                            }
                            return [2 /*return*/, result.configurations];
                    }
                });
            });
        };
        /**
         * Returns all results by invoking listConfigurations() repeatedly until all pages of results have been retrieved.
         * @returns {Promise<SecretsManagerV2.ConfigurationMetadata[]>}
         */
        ConfigurationsPager.prototype.getAll = function () {
            return __awaiter(this, void 0, void 0, function () {
                var results, nextPage;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            results = [];
                            _a.label = 1;
                        case 1:
                            if (!this.hasNext()) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.getNext()];
                        case 2:
                            nextPage = _a.sent();
                            results.push.apply(results, nextPage);
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/, results];
                    }
                });
            });
        };
        return ConfigurationsPager;
    }());
    SecretsManagerV2.ConfigurationsPager = ConfigurationsPager;
})(SecretsManagerV2 || (SecretsManagerV2 = {}));
module.exports = SecretsManagerV2;
//# sourceMappingURL=v2.js.map